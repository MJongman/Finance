USE [TestDWH]
GO
/****** Object:  User [NT AUTHORITY\SYSTEM]    Script Date: 27-8-2025 13:37:43 ******/
CREATE USER [NT AUTHORITY\SYSTEM] FOR LOGIN [NT AUTHORITY\SYSTEM] WITH DEFAULT_SCHEMA=[dbo]
GO
/****** Object:  DatabaseRole [SQLArcExtensionUserRole]    Script Date: 27-8-2025 13:37:43 ******/
CREATE ROLE [SQLArcExtensionUserRole]
GO
ALTER ROLE [SQLArcExtensionUserRole] ADD MEMBER [NT AUTHORITY\SYSTEM]
GO
/****** Object:  Schema [exe]    Script Date: 27-8-2025 13:37:43 ******/
CREATE SCHEMA [exe]
GO
/****** Object:  Schema [Test_Suite]    Script Date: 27-8-2025 13:37:43 ******/
CREATE SCHEMA [Test_Suite]
GO
/****** Object:  UserDefinedFunction [exe].[fn_GetLastLoadType]    Script Date: 27-8-2025 13:37:43 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

-- Function to get last used load type for a table
CREATE   FUNCTION [exe].[fn_GetLastLoadType]
(
    @TableName NVARCHAR(255)
)
RETURNS CHAR(1)
AS
BEGIN
    DECLARE @LastLoadType CHAR(1);
    
    SELECT TOP 1 @LastLoadType = Load_Type
    FROM exe.Lineage
    WHERE Table_Name = @TableName
        AND Load_Status = 'S'
        AND Load_Type IS NOT NULL
    ORDER BY Finish_Load DESC;
    
    RETURN @LastLoadType;
END
GO
/****** Object:  Table [exe].[Lineage]    Script Date: 27-8-2025 13:37:43 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [exe].[Lineage](
	[Lineage_Key] [int] IDENTITY(1,1) NOT NULL,
	[System] [nvarchar](25) NOT NULL,
	[Table_Name] [nvarchar](200) NOT NULL,
	[Start_Load] [datetime2](7) NOT NULL,
	[Finish_Load] [datetime2](7) NULL,
	[Last_Loaded_Date] [datetime2](7) NULL,
	[Type] [char](1) NOT NULL,
	[Load_Status] [char](1) NOT NULL,
	[Row_Count] [bigint] NULL,
	[Rows_Inserted] [bigint] NULL,
	[Rows_Updated] [bigint] NULL,
	[Rows_Deleted] [bigint] NULL,
	[Duration_Seconds]  AS (datediff(second,[Start_Load],[Finish_Load])),
	[Output_Message] [nvarchar](max) NULL,
	[Error_Number] [int] NULL,
	[Error_Severity] [int] NULL,
	[Error_State] [int] NULL,
	[Created_By] [nvarchar](128) NULL,
	[Host_Name] [nvarchar](128) NULL,
	[Load_Type] [char](1) NULL,
 CONSTRAINT [PK_Lineage] PRIMARY KEY CLUSTERED 
(
	[Lineage_Key] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]
GO
/****** Object:  View [exe].[vw_Last_Successful_Load]    Script Date: 27-8-2025 13:37:43 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

-- Create a view to get the last successful load information for each table
CREATE   VIEW [exe].[vw_Last_Successful_Load]
AS
WITH LastLoad AS (
    SELECT 
        System,
        Table_Name,
        Load_Type,
        Finish_Load,
        Row_Count,
        ROW_NUMBER() OVER (PARTITION BY System, Table_Name ORDER BY Finish_Load DESC) AS rn
    FROM exe.Lineage
    WHERE Load_Status = 'S'  -- Only successful loads
)
SELECT 
    System,
    Table_Name,
    Load_Type AS Last_Load_Type_Used,
    Finish_Load AS Last_Load_Date,
    Row_Count AS Last_Load_Row_Count
FROM LastLoad
WHERE rn = 1;
GO
/****** Object:  View [exe].[vw_Load_Type_History]    Script Date: 27-8-2025 13:37:43 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

-- Create a view to analyze load type patterns
CREATE   VIEW [exe].[vw_Load_Type_History]
AS
SELECT 
    l.System,
    l.Table_Name,
    l.Load_Type,
    COUNT(*) AS Load_Count,
    AVG(l.Row_Count) AS Avg_Row_Count,
    MIN(l.Finish_Load) AS First_Load,
    MAX(l.Finish_Load) AS Last_Load,
    AVG(DATEDIFF(SECOND, l.Start_Load, l.Finish_Load)) AS Avg_Duration_Seconds
FROM exe.Lineage l
WHERE l.Load_Status = 'S'
    AND l.Load_Type IS NOT NULL
GROUP BY l.System, l.Table_Name, l.Load_Type;
GO
/****** Object:  Table [exe].[Table_List]    Script Date: 27-8-2025 13:37:43 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [exe].[Table_List](
	[ID] [int] IDENTITY(1,1) NOT NULL,
	[System] [nvarchar](25) NOT NULL,
	[Execution_Order] [int] NOT NULL,
	[Schema_Name] [nvarchar](128) NOT NULL,
	[Table_Name] [nvarchar](100) NOT NULL,
	[Stored_Procedure_Name] [nvarchar](200) NULL,
	[Test_Table_Name] [nvarchar](100) NULL,
	[Load_Type] [char](1) NOT NULL,
	[Run_Group] [nvarchar](50) NULL,
	[Is_Active] [bit] NOT NULL,
	[Load_Pattern] [nvarchar](50) NULL,
	[Retry_Count] [int] NOT NULL,
	[Max_Retries] [int] NOT NULL,
	[Timeout_Seconds] [int] NULL,
	[Default_Load_Days] [int] NULL,
	[Default_Load_Date] [datetime2](7) NULL,
	[Use_Full_History] [bit] NOT NULL,
	[Last_Loaded_Date] [datetime2](7) NULL,
	[Load_Status] [char](1) NULL,
	[Load Pattern] [nvarchar](50) NULL,
	[Output_Message] [nvarchar](max) NULL,
	[Dependencies] [nvarchar](500) NULL,
	[Created_Date] [datetime2](7) NOT NULL,
	[Modified_Date] [datetime2](7) NOT NULL,
	[Modified_By] [nvarchar](128) NOT NULL,
	[Default_Load_Years] [int] NULL,
 CONSTRAINT [PK_Table_List] PRIMARY KEY CLUSTERED 
(
	[ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY],
 CONSTRAINT [UQ_Table_List_System_Table] UNIQUE NONCLUSTERED 
(
	[System] ASC,
	[Table_Name] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]
GO
/****** Object:  View [exe].[v_Table_Status]    Script Date: 27-8-2025 13:37:43 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

-- =============================================
-- COMPONENT 8: Monitoring Views
-- =============================================
CREATE   VIEW [exe].[v_Table_Status]
AS
SELECT 
    tl.[System],
    tl.[Table_Name],
    tl.[Load_Type],
    tl.[Run_Group],
    tl.[Is_Active],
    tl.[Load_Status],
    tl.[Last_Loaded_Date],
    tl.[Retry_Count],
    tl.[Max_Retries],
    l.[Current_Load_Start],
    l.[Current_Duration_Minutes],
    l.[Average_Duration_Minutes],
    l.[Last_Success_Date],
    l.[Last_Error_Date],
    l.[Success_Count_Last_7_Days],
    l.[Error_Count_Last_7_Days]
FROM [exe].[Table_List] AS tl
LEFT JOIN (
    SELECT 
        [System],
        [Table_Name],
        MAX(CASE WHEN [Load_Status] = 'P' THEN [Start_Load] END) AS [Current_Load_Start],
        DATEDIFF(MINUTE, 
            MAX(CASE WHEN [Load_Status] = 'P' THEN [Start_Load] END), 
            SYSDATETIME()
        ) AS [Current_Duration_Minutes],
        AVG(DATEDIFF(MINUTE, [Start_Load], [Finish_Load])) AS [Average_Duration_Minutes],
        MAX(CASE WHEN [Load_Status] = 'S' THEN [Finish_Load] END) AS [Last_Success_Date],
        MAX(CASE WHEN [Load_Status] = 'E' THEN [Finish_Load] END) AS [Last_Error_Date],
        SUM(CASE WHEN [Load_Status] = 'S' AND [Start_Load] > DATEADD(DAY, -7, SYSDATETIME()) THEN 1 ELSE 0 END) AS [Success_Count_Last_7_Days],
        SUM(CASE WHEN [Load_Status] = 'E' AND [Start_Load] > DATEADD(DAY, -7, SYSDATETIME()) THEN 1 ELSE 0 END) AS [Error_Count_Last_7_Days]
    FROM [exe].[Lineage]
    GROUP BY [System], [Table_Name]
) AS l ON tl.[System] = l.[System] AND tl.[Table_Name] = l.[Table_Name];

GO
/****** Object:  View [exe].[v_Load_Pattern_Reference]    Script Date: 27-8-2025 13:37:43 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

-- =====================================================
-- Create a reference view for load patterns
-- =====================================================
CREATE   VIEW [exe].[v_Load_Pattern_Reference]
AS
SELECT 
    Pattern,
    Description,
    Characteristics,
    Use_Case
FROM (VALUES
    ('TRUNCATE/INSERT', 
     'Full table refresh', 
     'Fast, minimal logging, no row-by-row processing',
     'Dimension tables, reference data'),
    
    ('DELETE_SYSTEM/INSERT', 
     'Delete specific system records then insert', 
     'Allows multiple systems in same table',
     'GL_Table with multiple source systems'),
    
    ('BATCH_DELETE/INSERT', 
     'Delete old data in batches, insert in batches', 
     'Manages memory and locks for large volumes',
     'High-volume transaction tables'),
    
    ('MERGE', 
     'Insert/Update/Delete in single statement', 
     'Handles all DML operations atomically',
     'SCD Type 1, Entity updates'),
    
    ('MERGE_PERIOD', 
     'MERGE with period-based filtering', 
     'Period-specific updates and deletes',
     'FINACC transactions with fiscal periods'),
    
    ('TRUNCATE/INSERT_PERIOD', 
     'Truncate and reload with period filter', 
     'Full refresh of specific period data',
     'Period-based fact tables')
) AS Patterns(Pattern, Description, Characteristics, Use_Case);
GO
/****** Object:  Table [dbo].[Calender]    Script Date: 27-8-2025 13:37:43 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[Calender](
	[Valuation Date] [date] NULL,
	[Display_Date] [varchar](20) NULL,
	[Day_Of_Month] [int] NULL,
	[Day_Name] [varchar](255) NULL,
	[Week] [int] NULL,
	[Month_Key] [int] NULL,
	[Month] [int] NULL,
	[Month_Name] [varchar](255) NULL,
	[Quarter] [int] NULL,
	[Quarter_Name] [varchar](255) NULL,
	[Year] [int] NULL,
	[First_Day_Of_Month] [datetime] NULL,
	[Last_Day_Of_Month] [datetime] NULL,
	[Day_Of_Week] [int] NULL,
	[Is_Week_Day] [int] NULL,
	[Day_Of_Quarter] [int] NULL,
	[Day_Of_Week_In_Year] [int] NULL,
	[Day_Of_Year] [int] NULL,
	[Week_Key] [int] NULL,
	[Week_Name] [varchar](20) NULL,
	[Year_Week_Name] [varchar](20) NULL,
	[Week_Of_Month] [int] NULL,
	[Week_Of_Quarter] [int] NULL,
	[Week_Of_Year] [int] NULL,
	[Year_Month_Name] [varchar](255) NULL,
	[Quarter_Key] [int] NULL,
	[Half_Year_Key] [int] NULL,
	[Half_Year] [int] NULL,
	[Half_Year_Name] [varchar](255) NULL,
	[Year_Half_Year_Name] [varchar](255) NULL,
	[Year_Quarter_Name] [varchar](255) NULL,
	[Year_Name] [varchar](20) NULL,
	[First_Day_Of_Quarter] [datetime] NULL,
	[Last_Day_Of_Quarter] [datetime] NULL,
	[First_Day_Of_Year] [datetime] NULL,
	[Last_Day_Of_Year] [datetime] NULL,
	[Year_Index] [int] NULL,
	[Quarter_Index] [int] NULL,
	[Month_Index] [int] NULL,
	[Week_Index] [int] NULL,
	[Lineage_Key] [bigint] NOT NULL
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[Cognos Accounts]    Script Date: 27-8-2025 13:37:43 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[Cognos Accounts](
	[Description Cognos accts] [nvarchar](250) NULL,
	[GL Account] [nvarchar](100) NULL,
	[Entity System Code] [nvarchar](250) NULL,
	[Entity Code] [nvarchar](100) NULL,
	[Balance/Cost Group] [nvarchar](100) NULL,
	[Cognos_Account] [nvarchar](100) NULL,
	[Counterparty Code] [nvarchar](250) NULL,
	[Counterparty Name] [nvarchar](250) NULL,
	[System] [nvarchar](100) NULL,
	[ID] [bigint] IDENTITY(1,1) NOT NULL,
	[Lineage_Key] [bigint] NULL
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[Entity]    Script Date: 27-8-2025 13:37:43 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[Entity](
	[Country] [varchar](50) NULL,
	[SB Code] [varchar](50) NULL,
	[Entity Code] [nvarchar](10) NULL,
	[Entity Description] [nvarchar](50) NULL,
	[Entity System Code] [nvarchar](10) NULL,
	[Entity System Description] [nvarchar](50) NULL,
	[System] [nvarchar](15) NULL,
	[Entity_Table_Key] [bigint] IDENTITY(1,1) NOT NULL,
	[Lineage_Key] [bigint] NOT NULL
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[Entity Adjustments]    Script Date: 27-8-2025 13:37:43 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[Entity Adjustments](
	[Entity Description] [nvarchar](250) NULL,
	[Entity System Code] [nvarchar](10) NULL,
	[Country] [nvarchar](2) NULL,
	[System] [nvarchar](15) NULL,
	[SB Code] [nvarchar](6) NULL,
	[Active] [nvarchar](100) NULL,
	[SB Description] [nvarchar](100) NULL,
	[Entity Code] [nvarchar](100) NULL,
	[Managerial Structure] [nvarchar](250) NULL,
	[Managerial Description] [nvarchar](250) NULL,
	[Lineage_Key] [bigint] NULL,
	[ID] [bigint] IDENTITY(1,1) NOT NULL
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[GL_Table]    Script Date: 27-8-2025 13:37:43 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[GL_Table](
	[BOEKJR] [smallint] NOT NULL,
	[Entity System Code] [nvarchar](5) NOT NULL,
	[BS\IS] [varchar](2) NULL,
	[Balance/Cost Group] [nvarchar](10) NULL,
	[Cost Center] [nvarchar](9) NULL,
	[GL Account] [nvarchar](20) NOT NULL,
	[GL Account Description] [nvarchar](250) NULL,
	[Cognos_Account] [nvarchar](100) NULL,
	[Description Cognos accts] [nvarchar](250) NULL,
	[System] [nvarchar](15) NOT NULL,
	[GL_Table_Key] [bigint] IDENTITY(1,1) NOT NULL,
	[Lineage_Key] [int] NOT NULL,
	[Counterparty Code] [nvarchar](250) NULL,
	[Counterparty Name] [nvarchar](250) NULL,
	[Entity Code] [nvarchar](250) NULL
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[GL_Transactions]    Script Date: 27-8-2025 13:37:43 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[GL_Transactions](
	[Amount] [decimal](18, 2) NULL,
	[JE Description] [nvarchar](500) NULL,
	[GL_Account] [nvarchar](20) NULL,
	[GL Account Description] [nvarchar](250) NULL,
	[Transaction Number] [nvarchar](50) NULL,
	[Cost_Center] [nvarchar](50) NULL,
	[Cost_Center_Description] [nvarchar](60) NULL,
	[Cost_Center2] [nvarchar](10) NULL,
	[Cost_Center_Description2] [nvarchar](60) NULL,
	[Cost_Center3] [nvarchar](10) NULL,
	[Cost_Center_Description3] [nvarchar](60) NULL,
	[Source] [nvarchar](10) NULL,
	[Balance/Cost Group] [nvarchar](10) NULL,
	[Posted By] [nvarchar](50) NULL,
	[Period] [int] NULL,
	[Date] [date] NULL,
	[Posted Date] [date] NULL,
	[Posted Time] [time](7) NULL,
	[Entity Code] [nvarchar](10) NULL,
	[Entity Description] [nvarchar](50) NULL,
	[Entity System Code] [nvarchar](10) NULL,
	[System] [nvarchar](20) NULL,
	[Lineage_Key_Origin] [bigint] NULL,
	[Lineage_Key] [bigint] NULL,
	[GL_Table_Key] [bigint] NULL,
	[Entity_Table_Key] [bigint] NULL,
	[Site_Table_Key] [bigint] NULL,
	[RECID] [bigint] NULL,
	[ID] [bigint] IDENTITY(1,1) NOT NULL,
	[Fiscal_Year] [bigint] NULL,
	[Vendor Number] [nvarchar](20) NULL,
	[Vendor Name] [nvarchar](60) NULL,
	[Table_Name] [nvarchar](50) NULL,
	[F_ID] [bigint] NULL
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[Ledgerbudget]    Script Date: 27-8-2025 13:37:43 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[Ledgerbudget](
	[Amount] [decimal](12, 2) NULL,
	[Analper] [int] NULL,
	[Fiscal Year] [smallint] NULL,
	[Comment] [nvarchar](60) NULL,
	[Date] [date] NULL,
	[Entity] [nvarchar](6) NULL,
	[Entity System Code] [nvarchar](5) NULL,
	[GL Account] [nvarchar](20) NULL,
	[Cost Center] [nvarchar](10) NULL,
	[System] [nvarchar](9) NULL,
	[Lineage_Key] [int] NOT NULL,
	[GL_Table_Key] [bigint] NULL,
	[Entity_Table_Key] [bigint] NULL,
	[Site_Table_Key] [bigint] NULL
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[Sites]    Script Date: 27-8-2025 13:37:43 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[Sites](
	[Region] [nvarchar](10) NULL,
	[Site_Name] [nvarchar](60) NULL,
	[Site_Nummer] [nvarchar](10) NULL,
	[Dimension] [int] NULL,
	[System] [nvarchar](9) NULL,
	[Site_Table_Key] [bigint] IDENTITY(1,1) NOT NULL,
	[Lineage_Key] [int] NOT NULL
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[Uploadfile]    Script Date: 27-8-2025 13:37:43 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[Uploadfile](
	[ID] [int] IDENTITY(1,1) NOT NULL,
	[LKQ BNF (SB0100)] [nvarchar](250) NULL,
	[Key] [nvarchar](250) NULL,
	[Entity System Code] [nvarchar](100) NULL,
	[System] [nvarchar](100) NULL,
	[Entity Code] [nvarchar](100) NULL,
	[Entity] [nvarchar](100) NULL,
	[Year] [nvarchar](100) NULL,
	[per] [nvarchar](100) NULL,
	[Period] [int] NULL,
	[GL account] [nvarchar](100) NULL,
	[Description] [nvarchar](100) NULL,
	[Balance/Cost] [nvarchar](100) NULL,
	[Description Balance/Cost group] [nvarchar](100) NULL,
	[Cost Center] [int] NULL,
	[Description Costcenter] [nvarchar](100) NULL,
	[BS / IS] [nvarchar](100) NULL,
	[Concatenate] [nvarchar](100) NULL,
	[Total Balance] [decimal](18, 2) NULL,
	[Adjustment] [decimal](18, 2) NULL,
	[Upload Balance] [decimal](18, 2) NULL,
	[Cognos account] [nvarchar](100) NULL,
	[Description Cognos accts] [nvarchar](100) NULL,
	[Managerial Description] [nvarchar](100) NULL,
	[Managerial Structure] [nvarchar](100) NULL,
	[Lineage_Key] [bigint] NOT NULL,
	[GL_Table_Key] [bigint] NULL,
	[Entity_Table_Key] [bigint] NULL
) ON [PRIMARY]
GO
/****** Object:  Table [Test_Suite].[Test_Suite_Results]    Script Date: 27-8-2025 13:37:43 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [Test_Suite].[Test_Suite_Results](
	[System] [nvarchar](50) NULL,
	[Table_Name] [nvarchar](50) NULL,
	[Count_Staging] [int] NULL,
	[Count_DWH] [int] NULL,
	[Date_Entry] [datetime2](7) NULL,
	[Count_Difference]  AS ([Count_Staging]-[Count_DWH])
) ON [PRIMARY]
GO
ALTER TABLE [exe].[Lineage] ADD  DEFAULT (sysdatetime()) FOR [Start_Load]
GO
ALTER TABLE [exe].[Lineage] ADD  DEFAULT (suser_sname()) FOR [Created_By]
GO
ALTER TABLE [exe].[Lineage] ADD  DEFAULT (host_name()) FOR [Host_Name]
GO
ALTER TABLE [exe].[Table_List] ADD  CONSTRAINT [DF__Table_Lis__Schem__5BE2A6F2]  DEFAULT ('dbo') FOR [Schema_Name]
GO
ALTER TABLE [exe].[Table_List] ADD  CONSTRAINT [DF__Table_Lis__Is_Ac__5DCAEF64]  DEFAULT ((1)) FOR [Is_Active]
GO
ALTER TABLE [exe].[Table_List] ADD  CONSTRAINT [DF__Table_Lis__Retry__5EBF139D]  DEFAULT ((0)) FOR [Retry_Count]
GO
ALTER TABLE [exe].[Table_List] ADD  CONSTRAINT [DF__Table_Lis__Max_R__5FB337D6]  DEFAULT ((3)) FOR [Max_Retries]
GO
ALTER TABLE [exe].[Table_List] ADD  CONSTRAINT [DF__Table_Lis__Defau__60A75C0F]  DEFAULT ((7)) FOR [Default_Load_Days]
GO
ALTER TABLE [exe].[Table_List] ADD  CONSTRAINT [DF__Table_Lis__Use_F__619B8048]  DEFAULT ((0)) FOR [Use_Full_History]
GO
ALTER TABLE [exe].[Table_List] ADD  CONSTRAINT [DF__Table_Lis__Creat__6383C8BA]  DEFAULT (sysdatetime()) FOR [Created_Date]
GO
ALTER TABLE [exe].[Table_List] ADD  CONSTRAINT [DF__Table_Lis__Modif__6477ECF3]  DEFAULT (sysdatetime()) FOR [Modified_Date]
GO
ALTER TABLE [exe].[Table_List] ADD  CONSTRAINT [DF__Table_Lis__Modif__656C112C]  DEFAULT (suser_sname()) FOR [Modified_By]
GO
ALTER TABLE [exe].[Table_List] ADD  DEFAULT ((2)) FOR [Default_Load_Years]
GO
ALTER TABLE [Test_Suite].[Test_Suite_Results] ADD  DEFAULT (getdate()) FOR [Date_Entry]
GO
ALTER TABLE [exe].[Lineage]  WITH CHECK ADD CHECK  (([Load_Status]='W' OR [Load_Status]='E' OR [Load_Status]='S' OR [Load_Status]='P'))
GO
ALTER TABLE [exe].[Lineage]  WITH CHECK ADD CHECK  (([Type]='I' OR [Type]='F'))
GO
ALTER TABLE [exe].[Table_List]  WITH CHECK ADD  CONSTRAINT [CK__Table_Lis__Load___5CD6CB2B] CHECK  (([Load_Type]='I' OR [Load_Type]='F'))
GO
ALTER TABLE [exe].[Table_List] CHECK CONSTRAINT [CK__Table_Lis__Load___5CD6CB2B]
GO
ALTER TABLE [exe].[Table_List]  WITH CHECK ADD  CONSTRAINT [CK__Table_Lis__Load___628FA481] CHECK  (([Load_Status]=NULL OR [Load_Status]='W' OR [Load_Status]='E' OR [Load_Status]='S' OR [Load_Status]='P'))
GO
ALTER TABLE [exe].[Table_List] CHECK CONSTRAINT [CK__Table_Lis__Load___628FA481]
GO
/****** Object:  StoredProcedure [dbo].[Load_Entity_AXBE_DATAAREA]    Script Date: 27-8-2025 13:37:43 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE   PROCEDURE [dbo].[Load_Entity_AXBE_DATAAREA]
    @LineageKey INT,
    @LoadType CHAR(1) = 'F',  -- F=Full, I=Incremental
    @LastLoadDate DATETIME2(7) = NULL
AS
BEGIN
    SET NOCOUNT ON;
    SET XACT_ABORT ON;
    
    -- Variables for tracking results
    DECLARE @RowCount INT = 0;
    DECLARE @RowsInserted INT = 0;
    DECLARE @RowsUpdated INT = 0;
    DECLARE @RowsDeleted INT = 0;
    DECLARE @OutputMessage NVARCHAR(MAX);
    DECLARE @System NVARCHAR(25) = 'AXBE';
    DECLARE @TableName NVARCHAR(100) = 'Entity_AXBE_DATAAREA';
    
    BEGIN TRY
        
        BEGIN TRANSACTION;
        
        -- Create temp table for capturing merge output
        CREATE TABLE #MergeOutput (
            ActionType NVARCHAR(10)
        );
        
        -- MERGE statement for Entity table
        MERGE [dbo].[Entity] AS target
        USING (
            SELECT 
                 ea.[Country]
                ,ea.[SB Code]
                ,ea.[Entity Code]
                ,ea.[Entity Description]
                ,e.[ID] AS [Entity System Code]
                ,e.[Description] AS [Entity System Description]
                ,'AXBE' AS [System]
                ,@LineageKey AS [Lineage_Key]
            FROM [SCH1SQL1V16].STAGING_AXBE.dbo.DATAAREA e
            INNER JOIN [Entity Adjustments] ea
                ON ea.[Entity System Code] = e.[ID] COLLATE SQL_Latin1_General_CP1_CI_AS
                AND ea.[System] = 'AXBE'
                AND ea.Active = 1
            -- For incremental loads, you could add a WHERE clause here if source has timestamps
            -- WHERE (@LoadType = 'F' OR e.ModifiedDate > @LastLoadDate)
        ) AS source 
        ON target.[System] = source.[System]
        AND target.[Entity System Code] = source.[Entity System Code]  COLLATE SQL_Latin1_General_CP1_CI_AS
        
        -- Update existing records if any column has changed
        WHEN MATCHED AND (
            ISNULL(target.[Country], '') != ISNULL(source.[Country], '') OR
            ISNULL(target.[SB Code], '') != ISNULL(source.[SB Code], '') OR
            ISNULL(target.[Entity Code], '') != ISNULL(source.[Entity Code], '') OR
            ISNULL(target.[Entity Description], '') != ISNULL(source.[Entity Description], '') OR
            ISNULL(target.[Entity System Description], '') != ISNULL(source.[Entity System Description]  COLLATE SQL_Latin1_General_CP1_CI_AS, '')
        ) THEN UPDATE SET
            [Country] = source.[Country],
            [SB Code] = source.[SB Code],
            [Entity Code] = source.[Entity Code],
            [Entity Description] = source.[Entity Description],
            [Entity System Description] = source.[Entity System Description],
            [Lineage_Key] = source.[Lineage_Key]
            
        -- Insert new records
        WHEN NOT MATCHED BY TARGET THEN INSERT (
            [Country],
            [SB Code],
            [Entity Code],
            [Entity Description],
            [Entity System Code],
            [Entity System Description],
            [System],
            [Lineage_Key]
        )
        VALUES (
            source.[Country],
            source.[SB Code],
            source.[Entity Code],
            source.[Entity Description],
            source.[Entity System Code],
            source.[Entity System Description],
            source.[System],
            source.[Lineage_Key]
        )
        
        -- Delete records that no longer exist in source (only for AXBE system)
        -- For incremental loads, you might want to skip the DELETE clause
        WHEN NOT MATCHED BY SOURCE 
            AND target.[System] = 'AXBE'
            AND @LoadType = 'F'  -- Only delete on full loads
        THEN DELETE
        
        -- Output clause to capture what happened
        OUTPUT $action INTO #MergeOutput(ActionType);
        
        -- Get the counts from the merge output
        SELECT 
            @RowsInserted = COUNT(CASE WHEN ActionType = 'INSERT' THEN 1 END),
            @RowsUpdated = COUNT(CASE WHEN ActionType = 'UPDATE' THEN 1 END),
            @RowsDeleted = COUNT(CASE WHEN ActionType = 'DELETE' THEN 1 END)
        FROM #MergeOutput;
        
        SET @RowCount = @RowsInserted + @RowsUpdated + @RowsDeleted;
        
        -- Clean up temp table
        DROP TABLE #MergeOutput;
        
        COMMIT TRANSACTION;
        
        -- Build success message
        SET @OutputMessage = CONCAT(
            'Entity AXBE load completed. ',
            'Type: ', CASE WHEN @LoadType = 'F' THEN 'Full' ELSE 'Incremental' END,
            ' | From: ', CONVERT(VARCHAR(30), @LastLoadDate, 120),
            ' | Rows affected: ', @RowCount,
            ' (Inserted: ', @RowsInserted,
            ', Updated: ', @RowsUpdated,
            ', Deleted: ', @RowsDeleted, ')'
        );
        
        -- Return results for lineage tracking
        -- This is what the framework expects
        SELECT @RowCount AS [RowCount], @OutputMessage AS OutputMessage;
        
        PRINT @OutputMessage;
        RETURN 0;
        
    END TRY
    BEGIN CATCH
        IF @@TRANCOUNT > 0
            ROLLBACK TRANSACTION;
        
        -- Clean up temp table if it exists
        IF OBJECT_ID('tempdb..#MergeOutput') IS NOT NULL
            DROP TABLE #MergeOutput;
        
        -- Capture error details
        DECLARE @ErrorMessage NVARCHAR(4000) = ERROR_MESSAGE();
        DECLARE @ErrorNumber INT = ERROR_NUMBER();
        DECLARE @ErrorSeverity INT = ERROR_SEVERITY();
        DECLARE @ErrorState INT = ERROR_STATE();
        DECLARE @ErrorLine INT = ERROR_LINE();
        
        -- Build error message
        SET @OutputMessage = CONCAT(
            'Error ', @ErrorNumber,
            ' at line ', @ErrorLine, ': ', @ErrorMessage
        );
        
        -- Return error for lineage tracking
        SET @RowCount = 0;
        SELECT @RowCount AS [RowCount], @OutputMessage AS OutputMessage;
        
        -- Log error for debugging
        PRINT @OutputMessage;
        
        -- Don't re-throw since we're returning the error info
        RETURN -1;
    END CATCH
END;
GO
/****** Object:  StoredProcedure [dbo].[Load_Entity_AXNL_DATAAREA]    Script Date: 27-8-2025 13:37:43 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE   PROCEDURE [dbo].[Load_Entity_AXNL_DATAAREA]
    @LineageKey INT,
    @LoadType CHAR(1) = 'F',  -- F=Full, I=Incremental
    @LastLoadDate DATETIME2(7) = NULL
AS
BEGIN
    SET NOCOUNT ON;
    SET XACT_ABORT ON;
    
    -- Variables for tracking results
    DECLARE @RowCount INT = 0;
    DECLARE @RowsInserted INT = 0;
    DECLARE @RowsUpdated INT = 0;
    DECLARE @RowsDeleted INT = 0;
    DECLARE @OutputMessage NVARCHAR(MAX);
    DECLARE @System NVARCHAR(25) = 'AXNL';
    DECLARE @TableName NVARCHAR(100) = 'Entity_AXNL_DATAAREA';
    
    BEGIN TRY
        
        BEGIN TRANSACTION;
        
        -- Create temp table for capturing merge output
        CREATE TABLE #MergeOutput (
            ActionType NVARCHAR(10)
        );
        
        -- MERGE statement for Entity table
        MERGE [dbo].[Entity] AS target
        USING (
            SELECT 
                 ea.[Country]
                ,ea.[SB Code]
                ,ea.[Entity Code]
                ,ea.[Entity Description]
                ,e.[ID] AS [Entity System Code]
                ,e.[Description] AS [Entity System Description]
                ,'AXNL' AS [System]
                ,@LineageKey AS [Lineage_Key]
            FROM [SCH1SQL1V16].STAGING_AXNL.dbo.DATAAREA e
            INNER JOIN [Entity Adjustments] ea
                ON ea.[Entity System Code] = e.[ID] COLLATE SQL_Latin1_General_CP1_CI_AS
                AND ea.[System] = 'AXNL'
                AND ea.Active = 1
            -- For incremental loads, you could add a WHERE clause here if source has timestamps
            -- WHERE (@LoadType = 'F' OR e.ModifiedDate > @LastLoadDate)
        ) AS source 
        ON target.[System] = source.[System]
        AND target.[Entity System Code] = source.[Entity System Code] COLLATE SQL_Latin1_General_CP1_CI_AS
        
        -- Update existing records if any column has changed
        WHEN MATCHED AND (
            ISNULL(target.[Country], '') != ISNULL(source.[Country], '') OR
            ISNULL(target.[SB Code], '') != ISNULL(source.[SB Code], '') OR
            ISNULL(target.[Entity Code], '') != ISNULL(source.[Entity Code], '') OR
            ISNULL(target.[Entity Description], '') != ISNULL(source.[Entity Description], '') OR
            ISNULL(target.[Entity System Description], '') != ISNULL(source.[Entity System Description] COLLATE SQL_Latin1_General_CP1_CI_AS, '')
        ) THEN UPDATE SET
            [Country] = source.[Country],
            [SB Code] = source.[SB Code],
            [Entity Code] = source.[Entity Code],
            [Entity Description] = source.[Entity Description],
            [Entity System Description] = source.[Entity System Description],
            [Lineage_Key] = source.[Lineage_Key]
            
        -- Insert new records
        WHEN NOT MATCHED BY TARGET THEN INSERT (
            [Country],
            [SB Code],
            [Entity Code],
            [Entity Description],
            [Entity System Code],
            [Entity System Description],
            [System],
            [Lineage_Key]
        )
        VALUES (
            source.[Country],
            source.[SB Code],
            source.[Entity Code],
            source.[Entity Description],
            source.[Entity System Code],
            source.[Entity System Description],
            source.[System],
            source.[Lineage_Key]
        )
        
        -- Delete records that no longer exist in source (only for AXNL system)
        -- For incremental loads, you might want to skip the DELETE clause
        WHEN NOT MATCHED BY SOURCE 
            AND target.[System] = 'AXNL'
            AND @LoadType = 'F'  -- Only delete on full loads
        THEN DELETE
        
        -- Output clause to capture what happened
        OUTPUT $action INTO #MergeOutput(ActionType);
        
        -- Get the counts from the merge output
        SELECT 
            @RowsInserted = COUNT(CASE WHEN ActionType = 'INSERT' THEN 1 END),
            @RowsUpdated = COUNT(CASE WHEN ActionType = 'UPDATE' THEN 1 END),
            @RowsDeleted = COUNT(CASE WHEN ActionType = 'DELETE' THEN 1 END)
        FROM #MergeOutput;
        
        SET @RowCount = @RowsInserted + @RowsUpdated + @RowsDeleted;
        
        -- Clean up temp table
        DROP TABLE #MergeOutput;
        
        COMMIT TRANSACTION;
        
        -- Build success message
        SET @OutputMessage = CONCAT(
            'Entity AXNL load completed. ',
            'Type: ', CASE WHEN @LoadType = 'F' THEN 'Full' ELSE 'Incremental' END,
            ' | From: ', CONVERT(VARCHAR(30), @LastLoadDate, 120),
            ' | Rows affected: ', @RowCount,
            ' (Inserted: ', @RowsInserted,
            ', Updated: ', @RowsUpdated,
            ', Deleted: ', @RowsDeleted, ')'
        );
        
        -- Return results for lineage tracking
        -- This is what the framework expects
        SELECT @RowCount AS [RowCount], @OutputMessage AS OutputMessage;
        
        PRINT @OutputMessage;
        RETURN 0;
        
    END TRY
    BEGIN CATCH
        IF @@TRANCOUNT > 0
            ROLLBACK TRANSACTION;
        
        -- Clean up temp table if it exists
        IF OBJECT_ID('tempdb..#MergeOutput') IS NOT NULL
            DROP TABLE #MergeOutput;
        
        -- Capture error details
        DECLARE @ErrorMessage NVARCHAR(4000) = ERROR_MESSAGE();
        DECLARE @ErrorNumber INT = ERROR_NUMBER();
        DECLARE @ErrorSeverity INT = ERROR_SEVERITY();
        DECLARE @ErrorState INT = ERROR_STATE();
        DECLARE @ErrorLine INT = ERROR_LINE();
        
        -- Build error message
        SET @OutputMessage = CONCAT(
            'Error ', @ErrorNumber,
            ' at line ', @ErrorLine, ': ', @ErrorMessage
        );
        
        -- Return error for lineage tracking
        SET @RowCount = 0;
        SELECT @RowCount AS [RowCount], @OutputMessage AS OutputMessage;
        
        -- Log error for debugging
        PRINT @OutputMessage;
        
        -- Don't re-throw since we're returning the error info
        RETURN -1;
    END CATCH
END;
GO
/****** Object:  StoredProcedure [dbo].[Load_Entity_FINACC_TFIRMA]    Script Date: 27-8-2025 13:37:43 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE   PROCEDURE [dbo].[Load_Entity_FINACC_TFIRMA]
    @LineageKey INT,
    @LoadType CHAR(1) = 'F',  -- F=Full, I=Incremental
    @LastLoadDate DATETIME2(7) = NULL
AS
BEGIN
    SET NOCOUNT ON;
    SET XACT_ABORT ON;
    
    -- Variables for tracking results
    DECLARE @RowCount INT = 0;
    DECLARE @RowsInserted INT = 0;
    DECLARE @RowsUpdated INT = 0;
    DECLARE @RowsDeleted INT = 0;
    DECLARE @OutputMessage NVARCHAR(MAX);
    DECLARE @System NVARCHAR(25) = 'FINACC';
    DECLARE @TableName NVARCHAR(100) = 'Entity_FINACC_TFIRMA';
    
    BEGIN TRY
        
        BEGIN TRANSACTION;
        
        -- Create temp table for capturing merge output
        CREATE TABLE #MergeOutput (
            ActionType NVARCHAR(10)
        );
        
        -- MERGE statement for Entity table
        MERGE [dbo].[Entity] AS target
        USING (
            SELECT 
                 ea.[Country]
                ,ea.[SB Code]
                ,ea.[Entity Code]
                ,ea.[Entity Description]
                ,T.[FIRKODE] AS [Entity System Code]
                ,T.[NAAM] AS [Entity System Description]
                ,'FINACC' AS [System]
                ,@LineageKey AS [Lineage_Key]
            FROM STAGING_FINACC.dbo.[TFIRMA] T
            INNER JOIN [Entity Adjustments] ea
                ON ea.[Entity System Code] = T.[FIRKODE] COLLATE SQL_Latin1_General_CP1_CI_AS
                AND ea.[System] = 'FINACC'
                AND ea.Active = 1
            -- For incremental loads, you could add a WHERE clause here if source has timestamps
            -- WHERE (@LoadType = 'F' OR T.ModifiedDate > @LastLoadDate)
        ) AS source 
        ON target.[System] = source.[System]
        AND target.[Entity System Code] = source.[Entity System Code] COLLATE SQL_Latin1_General_CP1_CI_AS
        
        -- Update existing records if any column has changed
        WHEN MATCHED AND (
            ISNULL(target.[Country], '') != ISNULL(source.[Country], '') OR
            ISNULL(target.[SB Code], '') != ISNULL(source.[SB Code], '') OR
            ISNULL(target.[Entity Code], '') != ISNULL(source.[Entity Code], '') OR
            ISNULL(target.[Entity Description], '') != ISNULL(source.[Entity Description], '') OR
            ISNULL(target.[Entity System Description], '') != ISNULL(source.[Entity System Description] COLLATE SQL_Latin1_General_CP1_CI_AS, '')
        ) THEN UPDATE SET
            [Country] = source.[Country],
            [SB Code] = source.[SB Code],
            [Entity Code] = source.[Entity Code],
            [Entity Description] = source.[Entity Description],
            [Entity System Description] = source.[Entity System Description],
            [Lineage_Key] = source.[Lineage_Key]
            
        -- Insert new records
        WHEN NOT MATCHED BY TARGET THEN INSERT (
            [Country],
            [SB Code],
            [Entity Code],
            [Entity Description],
            [Entity System Code],
            [Entity System Description],
            [System],
            [Lineage_Key]
        )
        VALUES (
            source.[Country],
            source.[SB Code],
            source.[Entity Code],
            source.[Entity Description],
            source.[Entity System Code],
            source.[Entity System Description],
            source.[System],
            source.[Lineage_Key]
        )
        
        -- Delete records that no longer exist in source (only for FINACC system)
        -- For incremental loads, you might want to skip the DELETE clause
        WHEN NOT MATCHED BY SOURCE 
            AND target.[System] = 'FINACC'
            AND @LoadType = 'F'  -- Only delete on full loads
        THEN DELETE
        
        -- Output clause to capture what happened
        OUTPUT $action INTO #MergeOutput(ActionType);
        
        -- Get the counts from the merge output
        SELECT 
            @RowsInserted = COUNT(CASE WHEN ActionType = 'INSERT' THEN 1 END),
            @RowsUpdated = COUNT(CASE WHEN ActionType = 'UPDATE' THEN 1 END),
            @RowsDeleted = COUNT(CASE WHEN ActionType = 'DELETE' THEN 1 END)
        FROM #MergeOutput;
        
        SET @RowCount = @RowsInserted + @RowsUpdated + @RowsDeleted;
        
        -- Clean up temp table
        DROP TABLE #MergeOutput;
        
        COMMIT TRANSACTION;
        
        -- Build success message
        SET @OutputMessage = CONCAT(
            'Entity FINACC load completed. ',
            'Type: ', CASE WHEN @LoadType = 'F' THEN 'Full' ELSE 'Incremental' END,
            ' | From: ', CONVERT(VARCHAR(30), @LastLoadDate, 120),
            ' | Rows affected: ', @RowCount,
            ' (Inserted: ', @RowsInserted,
            ', Updated: ', @RowsUpdated,
            ', Deleted: ', @RowsDeleted, ')'
        );
        
        -- Return results for lineage tracking
        -- This is what the framework expects
        SELECT @RowCount AS [RowCount], @OutputMessage AS OutputMessage;
        
        PRINT @OutputMessage;
        RETURN 0;
        
    END TRY
    BEGIN CATCH
        IF @@TRANCOUNT > 0
            ROLLBACK TRANSACTION;
        
        -- Clean up temp table if it exists
        IF OBJECT_ID('tempdb..#MergeOutput') IS NOT NULL
            DROP TABLE #MergeOutput;
        
        -- Capture error details
        DECLARE @ErrorMessage NVARCHAR(4000) = ERROR_MESSAGE();
        DECLARE @ErrorNumber INT = ERROR_NUMBER();
        DECLARE @ErrorSeverity INT = ERROR_SEVERITY();
        DECLARE @ErrorState INT = ERROR_STATE();
        DECLARE @ErrorLine INT = ERROR_LINE();
        
        -- Build error message
        SET @OutputMessage = CONCAT(
            'Error ', @ErrorNumber,
            ' at line ', @ErrorLine, ': ', @ErrorMessage
        );
        
        -- Return error for lineage tracking
        SET @RowCount = 0;
        SELECT @RowCount AS [RowCount], @OutputMessage AS OutputMessage;
        
        -- Log error for debugging
        PRINT @OutputMessage;
        
        -- Don't re-throw since we're returning the error info
        RETURN -1;
    END CATCH
END;
GO
/****** Object:  StoredProcedure [dbo].[Load_GL_Table_AXBE_LEDGERTABLE]    Script Date: 27-8-2025 13:37:43 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE   PROCEDURE [dbo].[Load_GL_Table_AXBE_LEDGERTABLE]
    @LineageKey INT,
    @LoadType CHAR(1) = 'F',  -- F=Full, I=Incremental
    @LastLoadDate DATETIME2(7) = NULL
AS
BEGIN
    SET NOCOUNT ON;
    SET XACT_ABORT ON;
    
    -- Variables for tracking results
    DECLARE @RowCount INT = 0;
    DECLARE @RowsInserted INT = 0;
    DECLARE @RowsUpdated INT = 0;
    DECLARE @RowsDeleted INT = 0;
    DECLARE @OutputMessage NVARCHAR(MAX);
    DECLARE @System NVARCHAR(25) = 'AXBE';
    DECLARE @TableName NVARCHAR(100) = 'GL_Table_AXBE_LEDGERTABLE';
    
    BEGIN TRY
        
        BEGIN TRANSACTION;
        
        -- Delete existing AXBE records (since this table does full refresh for AXBE)
        DELETE FROM [dbo].[GL_Table] 
        WHERE [System] = 'AXBE';
        
        SET @RowsDeleted = @@ROWCOUNT;
        
        -- Insert new data from staging
        INSERT INTO [dbo].[GL_Table] (
            [System],
            [BOEKJR],
            [Cognos_Account],
            [Description Cognos accts],
            [GL Account],
            [GL Account Description],
            [Entity System Code],
            [Entity Code],
            [BS\IS],
            [Balance/Cost Group],
            [Cost Center],
            [Counterparty Code],
            [Counterparty Name],
            [Lineage_Key]
        )
        SELECT 
            'AXBE' AS [System],
            0 AS [BOEKJR],  -- Cannot be NULL because this is the primary key of the table
            C.[Cognos_Account],
            C.[Description Cognos accts],
            ACCOUNTNUM AS [GL Account],
            ACCOUNTNAME AS [GL Account Description],
            DATAAREAID AS [Entity System Code],  -- Cannot be NULL because this is the primary key of the table
            C.[Entity Code],
            CASE 
                WHEN ISNUMERIC(COMPANYGROUPACCOUNT) = 1 THEN 'BS'
                WHEN COMPANYGROUPACCOUNT = ' ' THEN ' '
                ELSE 'IS'
            END AS [BS\IS],
            COMPANYGROUPACCOUNT AS [Balance/Cost Group],
            NULL AS [Cost Center],
            C.[Counterparty Code],
            C.[Counterparty Name],
            @LineageKey AS [Lineage_Key]
        FROM STAGING_AXBE.dbo.LEDGERTABLE l
        LEFT JOIN [dbo].[Cognos Accounts] C 
            ON 'AXBE' = C.System 
            AND C.[GL Account] = l.ACCOUNTNUM COLLATE SQL_Latin1_General_CP1_CI_AS
            AND C.[Balance/Cost Group] = l.COMPANYGROUPACCOUNT  COLLATE SQL_Latin1_General_CP1_CI_AS 
            AND C.[Entity System Code] = l.DATAAREAID  COLLATE SQL_Latin1_General_CP1_CI_AS
        -- For incremental loads, add WHERE clause if source has timestamps
        -- WHERE (@LoadType = 'F' OR l.ModifiedDate > @LastLoadDate)
        ;
        
        SET @RowsInserted = @@ROWCOUNT;
        SET @RowCount = @RowsInserted + @RowsDeleted;
        
        COMMIT TRANSACTION;
        
        -- Build success message
        SET @OutputMessage = CONCAT(
            'GL Table AXBE load completed. ',
            'Type: ', CASE WHEN @LoadType = 'F' THEN 'Full' ELSE 'Incremental' END,
            ' | From: ', CONVERT(VARCHAR(30), @LastLoadDate, 120),
            ' | Rows affected: ', @RowCount,
            ' (Inserted: ', @RowsInserted,
            ', Deleted: ', @RowsDeleted, ')'
        );
        
        -- Return results for lineage tracking
        -- This is what the framework expects
        SELECT @RowCount AS [RowCount], @OutputMessage AS OutputMessage;
        
        PRINT @OutputMessage;
        RETURN 0;
        
    END TRY
    BEGIN CATCH
        IF @@TRANCOUNT > 0
            ROLLBACK TRANSACTION;
        
        -- Capture error details
        DECLARE @ErrorMessage NVARCHAR(4000) = ERROR_MESSAGE();
        DECLARE @ErrorNumber INT = ERROR_NUMBER();
        DECLARE @ErrorSeverity INT = ERROR_SEVERITY();
        DECLARE @ErrorState INT = ERROR_STATE();
        DECLARE @ErrorLine INT = ERROR_LINE();
        
        -- Build error message
        SET @OutputMessage = CONCAT(
            'Error ', @ErrorNumber,
            ' at line ', @ErrorLine, ': ', @ErrorMessage
        );
        
        -- Return error for lineage tracking
        SET @RowCount = 0;
        SELECT @RowCount AS [RowCount], @OutputMessage AS OutputMessage;
        
        -- Log error for debugging
        PRINT @OutputMessage;
        
        -- Don't re-throw since we're returning the error info
        RETURN -1;
    END CATCH
END;
GO
/****** Object:  StoredProcedure [dbo].[Load_GL_Table_AXNL_LEDGERTABLE]    Script Date: 27-8-2025 13:37:43 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[Load_GL_Table_AXNL_LEDGERTABLE]
    @LineageKey INT,
    @LoadType CHAR(1) = 'F',  -- F=Full, I=Incremental
    @LastLoadDate DATETIME2(7) = NULL
AS
BEGIN
    SET NOCOUNT ON;
    SET XACT_ABORT ON;
    
    -- Variables for tracking results
    DECLARE @RowCount INT = 0;
    DECLARE @RowsInserted INT = 0;
    DECLARE @RowsUpdated INT = 0;
    DECLARE @RowsDeleted INT = 0;
    DECLARE @OutputMessage NVARCHAR(MAX);
    DECLARE @System NVARCHAR(25) = 'AXNL';
    DECLARE @TableName NVARCHAR(100) = 'GL_Table_AXNL_LEDGERTABLE';
    
    BEGIN TRY
        
        BEGIN TRANSACTION;
        
        -- Delete existing AXNL records (since this table does full refresh for AXNL)
        DELETE FROM [dbo].[GL_Table] 
        WHERE [System] = 'AXNL';
        
        SET @RowsDeleted = @@ROWCOUNT;
        
        -- Insert new data from staging
        INSERT INTO [dbo].[GL_Table] (
            [System],
            [BOEKJR],
            [Cognos_Account],
            [Description Cognos accts],
            [GL Account],
            [GL Account Description],
            [Entity System Code],
            [Entity Code],
            [BS\IS],
            [Balance/Cost Group],
            [Cost Center],
            [Counterparty Code],
            [Counterparty Name],
            [Lineage_Key]
        )
        SELECT
            'AXNL' AS [System],
            0 AS [BOEKJR],  -- Cannot be NULL because this is the primary key of the table
            C.[Cognos_Account],
            C.[Description Cognos accts],
            ACCOUNTNUM AS [GL Account],
            ACCOUNTNAME AS [GL Account Description],
            DATAAREAID AS [Entity System Code],  -- Cannot be NULL because this is the primary key of the table
            C.[Entity Code],
            CASE
                WHEN ISNUMERIC(COMPANYGROUPACCOUNT) = 1 THEN 'BS'
                WHEN COMPANYGROUPACCOUNT = ' ' THEN ' '
                ELSE 'IS'
            END AS [BS\IS],
            COMPANYGROUPACCOUNT AS [Balance/Cost Group],
            NULL AS [Cost Center],
            C.[Counterparty Code],
            C.[Counterparty Name],
            @LineageKey AS [Lineage_Key]
        FROM STAGING_AXNL.dbo.LEDGERTABLE l
        LEFT JOIN [dbo].[Cognos Accounts] C 
            ON 'AXNL' = C.System
            AND C.[GL Account] = l.ACCOUNTNUM COLLATE SQL_Latin1_General_CP1_CI_AS
            AND C.[Balance/Cost Group] = l.COMPANYGROUPACCOUNT COLLATE SQL_Latin1_General_CP1_CI_AS
            AND C.[Entity System Code] = l.DATAAREAID COLLATE SQL_Latin1_General_CP1_CI_AS
        -- For incremental loads, add WHERE clause if source has timestamps
        -- WHERE (@LoadType = 'F' OR l.ModifiedDate > @LastLoadDate)
        ;
        
        SET @RowsInserted = @@ROWCOUNT;
        SET @RowCount = @RowsInserted + @RowsDeleted;
        
        COMMIT TRANSACTION;
        
        -- Build success message
        SET @OutputMessage = CONCAT(
            'GL Table AXNL load completed. ',
            'Type: ', CASE WHEN @LoadType = 'F' THEN 'Full' ELSE 'Incremental' END,
            ' | From: ', CONVERT(VARCHAR(30), @LastLoadDate, 120),
            ' | Rows affected: ', @RowCount,
            ' (Inserted: ', @RowsInserted,
            ', Deleted: ', @RowsDeleted, ')'
        );
        
        -- Return results for lineage tracking
        -- This is what the framework expects
        SELECT @RowCount AS [RowCount], @OutputMessage AS OutputMessage;
        
        PRINT @OutputMessage;
        RETURN 0;
        
    END TRY
    BEGIN CATCH
        IF @@TRANCOUNT > 0
            ROLLBACK TRANSACTION;
        
        -- Capture error details
        DECLARE @ErrorMessage NVARCHAR(4000) = ERROR_MESSAGE();
        DECLARE @ErrorNumber INT = ERROR_NUMBER();
        DECLARE @ErrorSeverity INT = ERROR_SEVERITY();
        DECLARE @ErrorState INT = ERROR_STATE();
        DECLARE @ErrorLine INT = ERROR_LINE();
        
        -- Build error message
        SET @OutputMessage = CONCAT(
            'Error ', @ErrorNumber,
            ' at line ', @ErrorLine, ': ', @ErrorMessage
        );
        
        -- Return error for lineage tracking
        SET @RowCount = 0;
        SELECT @RowCount AS [RowCount], @OutputMessage AS OutputMessage;
        
        -- Log error for debugging
        PRINT @OutputMessage;
        
        -- Don't re-throw since we're returning the error info
        RETURN -1;
    END CATCH
END;
GO
/****** Object:  StoredProcedure [dbo].[Load_GL_Table_FINACC_TALGREK]    Script Date: 27-8-2025 13:37:43 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE   PROCEDURE [dbo].[Load_GL_Table_FINACC_TALGREK]
    @LineageKey INT,
    @LoadType CHAR(1) = 'F',  -- F=Full, I=Incremental
    @LastLoadDate DATETIME2(7) = NULL
AS
BEGIN
    SET NOCOUNT ON;
    SET XACT_ABORT ON;
    
    -- Variables for tracking results
    DECLARE @RowCount INT = 0;
    DECLARE @RowsInserted INT = 0;
    DECLARE @RowsUpdated INT = 0;
    DECLARE @RowsDeleted INT = 0;
    DECLARE @OutputMessage NVARCHAR(MAX);
    DECLARE @System NVARCHAR(25) = 'FINACC';
    DECLARE @TableName NVARCHAR(100) = 'GL_Table_FINACC_TALGREK';
    
    BEGIN TRY
        
        BEGIN TRANSACTION;
        
        -- Delete existing FINACC records (since this table does full refresh for FINACC)
        DELETE FROM [dbo].[GL_Table] 
        WHERE [System] = 'FINACC';
        
        SET @RowsDeleted = @@ROWCOUNT;
        
        -- Insert new data from staging
        INSERT INTO [dbo].[GL_Table] (
            [System],
            [BOEKJR],
            [Cognos_Account],
            [Description Cognos accts],
            [GL Account],
            [GL Account Description],
            [Entity System Code],
            [Entity Code],
            [BS\IS],
            [Balance/Cost Group],
            [Cost Center],
            [Counterparty Code],
            [Counterparty Name],
            [Lineage_Key]
        )
        SELECT
            'FINACC' AS [System],
            T.BOEKJR,
            C.[Cognos_Account],
            C.[Description Cognos accts],
            CAST(T.ALGREK AS NVARCHAR(20)) AS [GL Account],
            T.OMSCHR AS [GL Account Description],
            T.FIRKODE as [Entity System Code],
            C.[Entity Code],
            CASE
                WHEN TRY_CAST(
                    CASE 
                        WHEN T.KOSTSRT IS NOT NULL THEN T.KOSTSRT 
                        WHEN T.BALGRPPAS IS NOT NULL THEN T.BALGRPPAS 
                        ELSE T.BALGRPAKT 
                    END AS NUMERIC) IS NOT NULL THEN 'BS'
                WHEN 
                    CASE 
                        WHEN T.KOSTSRT IS NOT NULL THEN T.KOSTSRT 
                        WHEN T.BALGRPPAS IS NOT NULL THEN T.BALGRPPAS 
                        ELSE T.BALGRPAKT 
                    END = ' ' THEN ' '
                ELSE 'IS'
            END AS [BS\IS],
            CASE 
                WHEN T.KOSTSRT IS NOT NULL THEN T.KOSTSRT 
                WHEN T.BALGRPPAS IS NOT NULL THEN T.BALGRPPAS 
                ELSE T.BALGRPAKT 
            END AS [Balance/Cost Group],
            T.KOSTPL_2 AS [Cost Center],
            C.[Counterparty Code],
            C.[Counterparty Name],
            @LineageKey
        FROM STAGING_FINACC.dbo.[TALGREK] AS T
        LEFT JOIN [dbo].[Cognos Accounts] C 
            ON 'FINACC' = C.System
            AND C.[GL Account] = CAST(T.ALGREK AS NVARCHAR(20))
            AND C.[Balance/Cost Group] = CASE 
                                            WHEN T.KOSTSRT  IS NOT NULL THEN T.KOSTSRT COLLATE SQL_Latin1_General_CP1_CI_AS 
                                            WHEN T.BALGRPPAS IS NOT NULL THEN T.BALGRPPAS COLLATE SQL_Latin1_General_CP1_CI_AS
                                            ELSE T.BALGRPAKT COLLATE SQL_Latin1_General_CP1_CI_AS
                                        END
            AND C.[Entity System Code] = T.FIRKODE COLLATE SQL_Latin1_General_CP1_CI_AS
        -- For incremental loads, add WHERE clause if source has timestamps
        -- WHERE (@LoadType = 'F' OR T.ModifiedDate > @LastLoadDate)
        ;
        
        SET @RowsInserted = @@ROWCOUNT;
        SET @RowCount = @RowsInserted + @RowsDeleted;
        
        COMMIT TRANSACTION;
        
        -- Build success message
        SET @OutputMessage = CONCAT(
            'GL Table FINACC load completed. ',
            'Type: ', CASE WHEN @LoadType = 'F' THEN 'Full' ELSE 'Incremental' END,
            ' | From: ', CONVERT(VARCHAR(30), @LastLoadDate, 120),
            ' | Rows affected: ', @RowCount,
            ' (Inserted: ', @RowsInserted,
            ', Deleted: ', @RowsDeleted, ')'
        );
        
        -- Return results for lineage tracking
        -- This is what the framework expects
        SELECT @RowCount AS [RowCount], @OutputMessage AS OutputMessage;
        
        PRINT @OutputMessage;
        RETURN 0;
        
    END TRY
    BEGIN CATCH
        IF @@TRANCOUNT > 0
            ROLLBACK TRANSACTION;
        
        -- Capture error details
        DECLARE @ErrorMessage NVARCHAR(4000) = ERROR_MESSAGE();
        DECLARE @ErrorNumber INT = ERROR_NUMBER();
        DECLARE @ErrorSeverity INT = ERROR_SEVERITY();
        DECLARE @ErrorState INT = ERROR_STATE();
        DECLARE @ErrorLine INT = ERROR_LINE();
        
        -- Build error message
        SET @OutputMessage = CONCAT(
            'Error ', @ErrorNumber,
            ' at line ', @ErrorLine, ': ', @ErrorMessage
        );
        
        -- Return error for lineage tracking
        SET @RowCount = 0;
        SELECT @RowCount AS [RowCount], @OutputMessage AS OutputMessage;
        
        -- Log error for debugging
        PRINT @OutputMessage;
        
        -- Don't re-throw since we're returning the error info
        RETURN -1;
    END CATCH
END;
GO
/****** Object:  StoredProcedure [dbo].[Load_GL_Transactions_AXBE_LEDGERTRANS]    Script Date: 27-8-2025 13:37:43 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE   PROCEDURE [dbo].[Load_GL_Transactions_AXBE_LEDGERTRANS]
    @LineageKey INT,
    @LoadType CHAR(1) = 'I',  -- F=Full, I=Incremental (default to incremental)
    @LastLoadDate DATETIME2(7) = NULL
AS
BEGIN
    SET NOCOUNT ON;
    SET XACT_ABORT ON;
    
    -- Variables for tracking results
    DECLARE @RowCount INT = 0;
    DECLARE @RowsInserted INT = 0;
    DECLARE @RowsUpdated INT = 0;
    DECLARE @RowsDeleted INT = 0;
    DECLARE @OutputMessage NVARCHAR(MAX);
    DECLARE @System NVARCHAR(25) = 'AXBE';
    DECLARE @TableName NVARCHAR(100) = 'GL_Transactions_AXBE_LEDGERTRANS';
    
    -- Batch processing variables
    DECLARE @BatchSize INT = 1000000;
    DECLARE @MaxRow INT;
    DECLARE @CurrentRow INT;
    DECLARE @DeleteRowCount INT = 1;
    
    BEGIN TRY
        
        BEGIN TRANSACTION;
        
        -- Get the MIN and MAX ID from LEDGERTRANS for batch processing
        SELECT @CurrentRow = MIN(ID), @MaxRow = MAX(ID)
        FROM [STAGING_AXBE].dbo.LEDGERTRANS
        WHERE @LoadType = 'F' OR MODIFIEDDATETIME >= @LastLoadDate;
        
        -- Prepare deduplicated vendor transactions
        WITH Duplicates_Vendtrans AS (
            SELECT ACCOUNTNUM, VOUCHER, TRANSDATE, DATAAREAID
            FROM (
                SELECT DISTINCT ACCOUNTNUM, VOUCHER, TRANSDATE, DATAAREAID 
                FROM [STAGING_AXBE].[dbo].[VENDTRANS]
            ) VTS
            GROUP BY ACCOUNTNUM, VOUCHER, TRANSDATE, DATAAREAID
            HAVING COUNT(1) > 1
        )
        SELECT DISTINCT 
            VTS.VOUCHER,
            VTS.TRANSDATE,
            VTS.DATAAREAID,
            VTS.ACCOUNTNUM
        INTO #Exclude_Duplicates_Vendtrans
        FROM [STAGING_AXBE].[dbo].[VENDTRANS] VTS
        WHERE NOT EXISTS (
            SELECT 1 
            FROM Duplicates_Vendtrans D
            WHERE D.VOUCHER = VTS.VOUCHER
              AND D.TRANSDATE = VTS.TRANSDATE
              AND D.DATAAREAID = VTS.DATAAREAID
        )
        AND DOCUMENTNUM <> '';
        
        -- Delete old data for incremental load (in batches to avoid lock escalation)
        IF @LoadType = 'I' AND @LastLoadDate IS NOT NULL
        BEGIN
            WHILE @DeleteRowCount > 0
            BEGIN
                DELETE TOP (@BatchSize)
                FROM [dbo].[GL_Transactions]
                WHERE [Posted Date] >= @LastLoadDate 
                AND [System] = 'AXBE';
                
                SET @DeleteRowCount = @@ROWCOUNT;
                SET @RowsDeleted = @RowsDeleted + @DeleteRowCount;
            END;
        END
        ELSE IF @LoadType = 'F'
        BEGIN
            -- For full load, delete all AXBE records
            DELETE FROM [dbo].[GL_Transactions]
            WHERE [System] = 'AXBE';
            
            SET @RowsDeleted = @@ROWCOUNT;
        END
        
        -- Insert new data in batches
        WHILE @CurrentRow <= @MaxRow
        BEGIN
            INSERT INTO [dbo].[GL_Transactions] (
                [System],
                [Date],
                [Period],
                [Entity System Code],
                [GL_Account],
                [JE Description],
                [Amount],
                [Source],
                [Cost_Center],
                [Cost_Center_Description],
                [Cost_Center2],
                [Cost_Center_Description2],
                [Cost_Center3],
                [Cost_Center_Description3],
                [Transaction Number],
                [Balance/Cost Group],
                [Posted Time],
                [Posted By],
                [Posted Date],
                [Fiscal_Year],
                [Vendor Number],
                [Vendor Name],
                [Lineage_Key],
                [Lineage_Key_Origin],
                [GL_Table_Key],
                [Entity_Table_Key],
                [RECID],
                [Entity Code],
                [Entity Description],
                [GL Account Description]
            )
            SELECT
                'AXBE' AS [System],
                LT.TRANSDATE AS [Date],
                YEAR(LT.TRANSDATE) * 100 + MONTH(LT.TRANSDATE) AS [Period],
                LT.DATAAREAID AS [Entity System Code],
                CAST(LT.ACCOUNTNUM AS NVARCHAR(20)) AS [GL_Account],
                LT.TXT AS [JE Description],
                LT.AMOUNTMST AS [Amount],
                LT.JOURNALNUM AS [Source],
                LT.DIMENSION AS [Cost_Center],
                D1.DESCRIPTION AS [Cost_Center_Description],
                LT.DIMENSION2_ AS [Cost_Center2],
                D2.DESCRIPTION AS [Cost_Center_Description2],
                LT.DIMENSION3_ AS [Cost_Center3],
                D3.DESCRIPTION AS [Cost_Center_Description3],
                LT.VOUCHER AS [Transaction Number],
                l.[Balance/Cost Group],
                LT.MODIFIEDDATETIME AS [Posted Time],
                LT.MODIFIEDBY AS [Posted By],
                CAST(LT.MODIFIEDDATETIME AS DATE) AS [Posted Date],
                YEAR(LT.TRANSDATE) AS [Fiscal_Year],
                VT.ACCOUNTNUM AS [Vendor Number],
                VT.NAME AS [Vendor Name],
                @LineageKey AS [Lineage_Key],
                LT.Lineage_Key AS [Lineage_Key_Origin],
                l.GL_Table_Key,
                e.Entity_Table_Key,
                LT.RECID,
                e.[Entity Code],
                e.[Entity Description],
                l.[GL Account Description]
            FROM [STAGING_AXBE].[dbo].LEDGERTRANS LT
            LEFT JOIN [STAGING_AXBE].[dbo].[DIMENSIONS] D1 
                ON (D1.DATAAREAID = LT.DATAAREAID OR (D1.DATAAREAID = 'vir' AND LT.DATAAREAID <> '700'))
                AND D1.NUM = LT.DIMENSION 
                AND D1.DIMENSIONCODE = 0
            LEFT JOIN [STAGING_AXBE].[dbo].[DIMENSIONS] D2 
                ON (D2.DATAAREAID = LT.DATAAREAID OR (D2.DATAAREAID = 'vir' AND LT.DATAAREAID <> '700'))
                AND D2.NUM = LT.DIMENSION2_ 
                AND D2.DIMENSIONCODE = 1
            LEFT JOIN [STAGING_AXBE].[dbo].[DIMENSIONS] D3 
                ON (D3.DATAAREAID = LT.DATAAREAID OR (D3.DATAAREAID = 'vir' AND LT.DATAAREAID <> '700'))
                AND D3.NUM = LT.DIMENSION3_ 
                AND D3.DIMENSIONCODE = 2
            LEFT JOIN #Exclude_Duplicates_Vendtrans VTS 
                ON VTS.VOUCHER = LT.VOUCHER 
                AND VTS.TRANSDATE = LT.TRANSDATE 
                AND VTS.DATAAREAID = LT.DATAAREAID
            LEFT JOIN [STAGING_AXBE].[dbo].[VENDTABLE] VT 
                ON VT.ACCOUNTNUM = VTS.ACCOUNTNUM 
                AND VT.DATAAREAID = VTS.DATAAREAID
            LEFT JOIN [DWH_FINANCE].dbo.GL_Table l 
                ON l.System = 'AXBE'
                AND ((l.[Entity System Code] = LT.DATAAREAID) OR (l.[Entity System Code] = 'vir' AND LT.DATAAREAID <> '700'))
                AND l.[GL Account] = LT.ACCOUNTNUM
            LEFT JOIN [DWH_FINANCE].dbo.Entity e 
                ON e.System = 'AXBE' 
                AND e.[Entity System Code] = LT.DATAAREAID
            WHERE 
                ((LT.DATAAREAID = '700' AND LT.POSTING <> 19) OR (LT.DATAAREAID <> '700'))
                AND (
                    -- For batch processing: use ID range for full load
                    (@LoadType = 'F' AND LT.ID BETWEEN @CurrentRow AND @CurrentRow + @BatchSize - 1)
                    OR 
                    -- For incremental: use date filter
                    (@LoadType = 'I' AND LT.MODIFIEDDATETIME >= @LastLoadDate AND LT.ID BETWEEN @CurrentRow AND @CurrentRow + @BatchSize - 1)
                );
            
            SET @RowsInserted = @RowsInserted + @@ROWCOUNT;
            
            -- Move to next batch
            SET @CurrentRow = @CurrentRow + @BatchSize;
            
            -- For incremental loads with date filter, we can break after first batch if filtering by date
            IF @LoadType = 'I' AND @LastLoadDate IS NOT NULL AND NOT EXISTS (
                SELECT 1 FROM [STAGING_AXBE].dbo.LEDGERTRANS 
                WHERE MODIFIEDDATETIME >= @LastLoadDate 
                AND ID >= @CurrentRow
            )
                BREAK;
        END;
        
        -- Clean up temp table
        DROP TABLE #Exclude_Duplicates_Vendtrans;
        
        SET @RowCount = @RowsInserted;
        
        COMMIT TRANSACTION;
        
        -- Build success message
        SET @OutputMessage = CONCAT(
            'GL Transactions AXBE load completed. ',
            'Type: ', CASE WHEN @LoadType = 'F' THEN 'Full' ELSE 'Incremental' END,
            ' | From: ', CONVERT(VARCHAR(30), @LastLoadDate, 120),
            ' | Rows affected: ', @RowCount,
            ' (Inserted: ', @RowsInserted,
            ', Deleted: ', @RowsDeleted, ')',
            ' | Batch size: ', @BatchSize
        );
        
        -- Return results for lineage tracking
        SELECT @RowCount AS [RowCount], @OutputMessage AS OutputMessage;
        
        PRINT @OutputMessage;
        RETURN 0;
        
    END TRY
    BEGIN CATCH
        IF @@TRANCOUNT > 0
            ROLLBACK TRANSACTION;
        
        -- Clean up temp table if exists
        IF OBJECT_ID('tempdb..#Exclude_Duplicates_Vendtrans') IS NOT NULL
            DROP TABLE #Exclude_Duplicates_Vendtrans;
        
        -- Capture error details
        DECLARE @ErrorMessage NVARCHAR(4000) = ERROR_MESSAGE();
        DECLARE @ErrorNumber INT = ERROR_NUMBER();
        DECLARE @ErrorSeverity INT = ERROR_SEVERITY();
        DECLARE @ErrorState INT = ERROR_STATE();
        DECLARE @ErrorLine INT = ERROR_LINE();
        
        -- Build error message
        SET @OutputMessage = CONCAT(
            'Error ', @ErrorNumber,
            ' at line ', @ErrorLine, ': ', @ErrorMessage
        );
        
        -- Return error for lineage tracking
        SET @RowCount = 0;
        SELECT @RowCount AS [RowCount], @OutputMessage AS OutputMessage;
        
        -- Log error for debugging
        PRINT @OutputMessage;
        
        RETURN -1;
    END CATCH
END;
GO
/****** Object:  StoredProcedure [dbo].[Load_GL_Transactions_AXNL_LEDGERTRANS]    Script Date: 27-8-2025 13:37:43 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE   PROCEDURE [dbo].[Load_GL_Transactions_AXNL_LEDGERTRANS]
    @LineageKey INT,
    @LoadType CHAR(1) = 'I',  -- F=Full, I=Incremental (default to incremental)
    @LastLoadDate DATETIME2(7) = NULL
AS
BEGIN
    SET NOCOUNT ON;
    SET XACT_ABORT ON;
    
    -- Variables for tracking results
    DECLARE @RowCount INT = 0;
    DECLARE @RowsInserted INT = 0;
    DECLARE @RowsUpdated INT = 0;
    DECLARE @RowsDeleted INT = 0;
    DECLARE @OutputMessage NVARCHAR(MAX);
    DECLARE @System NVARCHAR(25) = 'AXNL';
    DECLARE @TableName NVARCHAR(100) = 'GL_Transactions_AXNL_LEDGERTRANS';
    
    -- Batch processing variables
    DECLARE @BatchSize INT = 1000000;
    DECLARE @MaxRow INT;
    DECLARE @CurrentRow INT;
    DECLARE @DeleteRowCount INT = 1;
    
    BEGIN TRY
        
        BEGIN TRANSACTION;
        
        -- Get the MIN and MAX ID from LEDGERTRANS for batch processing
        SELECT @CurrentRow = MIN(ID), @MaxRow = MAX(ID)
        FROM [STAGING_AXNL].dbo.LEDGERTRANS
        WHERE @LoadType = 'F' OR MODIFIEDDATETIME >= @LastLoadDate;
        
        -- Prepare deduplicated vendor transactions
        WITH Duplicates_Vendtrans AS (
            SELECT ACCOUNTNUM, VOUCHER, TRANSDATE, DATAAREAID
            FROM (
                SELECT DISTINCT ACCOUNTNUM, VOUCHER, TRANSDATE, DATAAREAID 
                FROM [STAGING_AXNL].[dbo].[VENDTRANS]
            ) VTS
            GROUP BY ACCOUNTNUM, VOUCHER, TRANSDATE, DATAAREAID
            HAVING COUNT(1) > 1
        )
        SELECT DISTINCT 
            VTS.VOUCHER,
            VTS.TRANSDATE,
            VTS.DATAAREAID,
            VTS.ACCOUNTNUM
        INTO #Exclude_Duplicates_Vendtrans
        FROM [STAGING_AXNL].[dbo].[VENDTRANS] VTS
        WHERE NOT EXISTS (
            SELECT 1 
            FROM Duplicates_Vendtrans D
            WHERE D.VOUCHER = VTS.VOUCHER
              AND D.TRANSDATE = VTS.TRANSDATE
              AND D.DATAAREAID = VTS.DATAAREAID
        )
        AND DOCUMENTNUM <> '';
        
        -- Delete old data for incremental load (in batches to avoid lock escalation)
        IF @LoadType = 'I' AND @LastLoadDate IS NOT NULL
        BEGIN
            WHILE @DeleteRowCount > 0
            BEGIN
                DELETE TOP (@BatchSize)
                FROM [dbo].[GL_Transactions]
                WHERE [Posted Date] >= @LastLoadDate 
                AND [System] = 'AXNL';
                
                SET @DeleteRowCount = @@ROWCOUNT;
                SET @RowsDeleted = @RowsDeleted + @DeleteRowCount;
            END;
        END
        ELSE IF @LoadType = 'F'
        BEGIN
            -- For full load, delete all AXNL records
            DELETE FROM [dbo].[GL_Transactions]
            WHERE [System] = 'AXNL';
            
            SET @RowsDeleted = @@ROWCOUNT;
        END
        
        -- Insert new data in batches
        WHILE @CurrentRow <= @MaxRow
        BEGIN
            INSERT INTO [dbo].[GL_Transactions] (
                [System],
                [Date],
                [Period],
                [Entity System Code],
                [GL_Account],
                [JE Description],
                [Amount],
                [Source],
                [Cost_Center],
                [Cost_Center_Description],
                [Cost_Center2],
                [Cost_Center_Description2],
                [Cost_Center3],
                [Cost_Center_Description3],
                [Transaction Number],
                [Balance/Cost Group],
                [Posted Time],
                [Posted By],
                [Posted Date],
                [Fiscal_Year],
                [Vendor Number],
                [Vendor Name],
                [RECID],
                [Entity Code],
                [Entity Description],
                [GL Account Description],
                [Lineage_Key],
                [Lineage_Key_Origin],
                [GL_Table_Key],
                [Entity_Table_Key]
            )
            SELECT
                'AXNL' AS [System],
                LT.TRANSDATE AS [Date],
                YEAR(LT.TRANSDATE) * 100 + MONTH(LT.TRANSDATE) AS [Period],
                LT.DATAAREAID AS [Entity System Code],
                CAST(LT.ACCOUNTNUM AS NVARCHAR(20)) AS [GL_Account],
                LT.TXT AS [JE Description],
                LT.AMOUNTMST AS [Amount],
                LT.JOURNALNUM AS [Source],
                LT.DIMENSION AS [Cost_Center],
                D1.DESCRIPTION AS [Cost_Center_Description],
                LT.DIMENSION2_ AS [Cost_Center2],
                D2.DESCRIPTION AS [Cost_Center_Description2],
                LT.DIMENSION3_ AS [Cost_Center3],
                D3.DESCRIPTION AS [Cost_Center_Description3],
                LT.VOUCHER AS [Transaction Number],
                l.[Balance/Cost Group],
                LT.MODIFIEDDATETIME AS [Posted Time],
                LT.MODIFIEDBY AS [Posted By],
                CAST(LT.MODIFIEDDATETIME AS DATE) AS [Posted Date],
                YEAR(LT.TRANSDATE) AS [Fiscal_Year],
                VT.ACCOUNTNUM AS [Vendor Number],
                VT.NAME AS [Vendor Name],
                LT.RECID,
                e.[Entity Code],
                e.[Entity Description],
                l.[GL Account Description],
                @LineageKey AS [Lineage_Key],
                LT.Lineage_Key AS [Lineage_Key_Origin],
                l.GL_Table_Key,
                e.Entity_Table_Key
            FROM [STAGING_AXNL].[dbo].LEDGERTRANS LT
            LEFT JOIN [STAGING_AXNL].[dbo].[DIMENSIONS] D1 
                ON D1.DATAAREAID = 'vir' 
                AND D1.NUM = LT.DIMENSION 
                AND D1.DIMENSIONCODE = 0
            LEFT JOIN [STAGING_AXNL].[dbo].[DIMENSIONS] D2 
                ON D2.DATAAREAID = 'vir' 
                AND D2.NUM = LT.DIMENSION2_ 
                AND D2.DIMENSIONCODE = 1
            LEFT JOIN [STAGING_AXNL].[dbo].[DIMENSIONS] D3 
                ON D3.DATAAREAID = 'vir' 
                AND D3.NUM = LT.DIMENSION3_ 
                AND D3.DIMENSIONCODE = 2
            LEFT JOIN #Exclude_Duplicates_Vendtrans VTS 
                ON VTS.VOUCHER = LT.VOUCHER 
                AND VTS.TRANSDATE = LT.TRANSDATE 
                AND VTS.DATAAREAID = LT.DATAAREAID
            LEFT JOIN [STAGING_AXNL].[dbo].[VENDTABLE] VT 
                ON VT.ACCOUNTNUM = VTS.ACCOUNTNUM 
                AND VT.DATAAREAID = VTS.DATAAREAID
            LEFT JOIN [DWH_FINANCE].dbo.GL_Table l 
                ON l.System = 'AXNL' 
                AND l.[Entity System Code] = 'vir'  -- AXNL always uses 'vir' per the GL_Table logic
                AND l.[GL Account] = LT.ACCOUNTNUM
            LEFT JOIN [DWH_FINANCE].dbo.Entity e 
                ON e.System = 'AXNL' 
                AND e.[Entity System Code] = LT.DATAAREAID
            WHERE LT.POSTING <> 19  -- Exclude POSTING type 19
                AND (
                    -- For batch processing: use ID range for full load
                    (@LoadType = 'F' AND LT.ID BETWEEN @CurrentRow AND @CurrentRow + @BatchSize - 1)
                    OR 
                    -- For incremental: use date filter
                    (@LoadType = 'I' AND LT.MODIFIEDDATETIME >= @LastLoadDate AND LT.ID BETWEEN @CurrentRow AND @CurrentRow + @BatchSize - 1)
                );
            
            SET @RowsInserted = @RowsInserted + @@ROWCOUNT;
            
            -- Move to next batch
            SET @CurrentRow = @CurrentRow + @BatchSize;
            
            -- For incremental loads with date filter, we can break after first batch if filtering by date
            IF @LoadType = 'I' AND @LastLoadDate IS NOT NULL AND NOT EXISTS (
                SELECT 1 FROM [STAGING_AXNL].dbo.LEDGERTRANS 
                WHERE MODIFIEDDATETIME >= @LastLoadDate 
                AND ID >= @CurrentRow
            )
                BREAK;
        END;
        
        -- Clean up temp table
        DROP TABLE #Exclude_Duplicates_Vendtrans;
        
        SET @RowCount = @RowsInserted;
        
        COMMIT TRANSACTION;
        
        -- Build success message
        SET @OutputMessage = CONCAT(
            'GL Transactions AXNL load completed. ',
            'Type: ', CASE WHEN @LoadType = 'F' THEN 'Full' ELSE 'Incremental' END,
            ' | From: ', CONVERT(VARCHAR(30), @LastLoadDate, 120),
            ' | Rows affected: ', @RowCount,
            ' (Inserted: ', @RowsInserted,
            ', Deleted: ', @RowsDeleted, ')',
            ' | Batch size: ', @BatchSize
        );
        
        -- Return results for lineage tracking
        SELECT @RowCount AS [RowCount], @OutputMessage AS OutputMessage;
        
        PRINT @OutputMessage;
        RETURN 0;
        
    END TRY
    BEGIN CATCH
        IF @@TRANCOUNT > 0
            ROLLBACK TRANSACTION;
        
        -- Clean up temp table if exists
        IF OBJECT_ID('tempdb..#Exclude_Duplicates_Vendtrans') IS NOT NULL
            DROP TABLE #Exclude_Duplicates_Vendtrans;
        
        -- Capture error details
        DECLARE @ErrorMessage NVARCHAR(4000) = ERROR_MESSAGE();
        DECLARE @ErrorNumber INT = ERROR_NUMBER();
        DECLARE @ErrorSeverity INT = ERROR_SEVERITY();
        DECLARE @ErrorState INT = ERROR_STATE();
        DECLARE @ErrorLine INT = ERROR_LINE();
        
        -- Build error message
        SET @OutputMessage = CONCAT(
            'Error ', @ErrorNumber,
            ' at line ', @ErrorLine, ': ', @ErrorMessage
        );
        
        -- Return error for lineage tracking
        SET @RowCount = 0;
        SELECT @RowCount AS [RowCount], @OutputMessage AS OutputMessage;
        
        -- Log error for debugging
        PRINT @OutputMessage;
        
        RETURN -1;
    END CATCH
END;
GO
/****** Object:  StoredProcedure [dbo].[Load_GL_Transactions_FINACC_TAANDAGD]    Script Date: 27-8-2025 13:37:43 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE   PROCEDURE [dbo].[Load_GL_Transactions_FINACC_TAANDAGD]
    @LineageKey INT,
    @LoadType CHAR(1) = 'I',  -- F=Full, I=Incremental
    @LastLoadDate DATETIME2(7) = NULL
AS
BEGIN
    SET NOCOUNT ON;
    SET XACT_ABORT ON;
    
    -- Variables for tracking results
    DECLARE @RowCount INT = 0;
    DECLARE @RowsInserted INT = 0;
    DECLARE @RowsUpdated INT = 0;
    DECLARE @RowsDeleted INT = 0;
    DECLARE @OutputMessage NVARCHAR(MAX);
    DECLARE @System NVARCHAR(25) = 'FINACC';
    DECLARE @TableName NVARCHAR(100) = 'GL_Transactions_FINACC_TAANDAGD';
    
    -- Period-based variables for FINACC
    DECLARE @CurrentYear INT = YEAR(GETDATE());
    DECLARE @PreviousYear INT = YEAR(GETDATE()) - 1;
    DECLARE @CurrentPeriode INT = MONTH(GETDATE());
    DECLARE @LastPeriodYear INT = CASE WHEN MONTH(GETDATE()) = 1 THEN YEAR(GETDATE()) - 1 ELSE YEAR(GETDATE()) END;
    DECLARE @LastPeriode INT = CASE WHEN MONTH(GETDATE()) = 1 THEN 12 ELSE MONTH(GETDATE()) - 1 END;
    
    BEGIN TRY
        BEGIN TRANSACTION;
        
        -- Create temp table to capture merge results
        CREATE TABLE #MergeOutput (
            ActionType NVARCHAR(10)
        );
        
        -- MERGE statement for GL_Transactions
        MERGE [dbo].[GL_Transactions] AS target
        USING (
            SELECT
                TD.BEDRAG AS Amount,
                COALESCE(T.KOSTSRT, T.BALGRPPAS, T.BALGRPAKT) AS [Balance/Cost Group],
                TC.KOSTPL2 AS [Cost_Center],
                NULL AS [Cost_Center_Description],  -- Add if available
                NULL AS [Cost_Center2],
                NULL AS [Cost_Center_Description2],
                NULL AS [Cost_Center3],
                NULL AS [Cost_Center_Description3],
                CONCAT(TD.TYPE_DAGB, ' / ', TD.DAGBOEK) AS Source,
                CAST(CASE 
                    WHEN MONTH(TD.DATUM) <> TD.PERIODE OR YEAR(TD.DATUM) <> TD.BOEKJR
                    THEN EOMONTH(DATEFROMPARTS(TD.BOEKJR, IIF(TD.PERIODE = 0, 1, TD.PERIODE), 1))
                    ELSE TD.DATUM 
                END AS DATE) AS [Date],
                TD.OPMERK AS [JE Description],
                TD.FIRKODE AS [Entity System Code],
                CAST(TD.ALGREK AS NVARCHAR(20)) AS [GL_Account],
                TD.USCREA AS [Posted By],
                CAST(TD.CREA AS DATETIME2) AS [Posted Time],
                CAST(TD.CREA AS DATE) AS [Posted Date],
                TD.BOEKJR * 100 + TD.PERIODE AS [Period],
                'FINACC' AS [System],
                L.NAAM AS [Vendor Name],
                L.LEVERNR AS [Vendor Number],
                TD.FAKTNR AS [Transaction Number],
                e.[Entity Code],
                e.[Entity Description],
                L2.[GL Account Description],
                @LineageKey AS [Lineage_Key],
                TD.Lineage_Key AS Lineage_Key_Origin,
                L2.GL_Table_Key,
                e.Entity_Table_Key,
                TD.BOEKJR AS Fiscal_Year,
                NULL AS RECID,  -- FINACC doesn't have RECID
                'TAANDAGD' AS Table_Name,  -- Track source table
                TD.PK AS F_ID  -- FINACC primary key
            FROM [STAGING_FINACC].dbo.TAANDAGD TD
            LEFT JOIN [STAGING_FINACC].dbo.TALGREK T 
                ON T.BOEKJR = TD.BOEKJR 
                AND T.FIRKODE = TD.FIRKODE 
                AND T.ALGREK = TD.ALGREK
            LEFT JOIN [STAGING_FINACC].dbo.TLEVER L 
                ON L.LEVERNR = TD.REL_LEVERNR 
                AND L.FIRKODE = TD.FIRKODE
            LEFT JOIN STAGING_FINACC.dbo.TAN_DET TAND
                ON TAND.BEDRAG = TD.BEDRAG 
                AND TAND.FIRKODE = TD.FIRKODE 
                AND TAND.BOEKJR = TD.BOEKJR 
                AND TAND.PERIODE = TD.PERIODE 
                AND TAND.VERRNR = TD.FAKTNR 
                AND TAND.VERRVOLGNR = TD.VOLGNR 
                AND TAND.VNALGREK = TD.ALGREK
            LEFT JOIN STAGING_FINACC.dbo.TAN_COMBH TC
                ON TC.SEQ = TAND.NRSEQ 
                AND TC.FIRKODE = TAND.FIRKODE
            LEFT JOIN [DWH_FINANCE].dbo.GL_Table L2 
                ON L2.System = 'FINACC' 
                AND L2.[Entity System Code] = TD.FIRKODE 
                AND L2.[GL Account] = CAST(TD.ALGREK AS NVARCHAR(20))
                AND L2.BOEKJR = TD.BOEKJR
            LEFT JOIN [DWH_FINANCE].dbo.Entity e 
                ON e.System = 'FINACC' 
                AND e.[Entity System Code] = TD.FIRKODE
            WHERE 
                CASE 
                    -- Full load: load current and previous year
                    WHEN @LoadType = 'F' THEN 
                        CASE WHEN TD.BOEKJR IN (@CurrentYear, @PreviousYear) THEN 1 ELSE 0 END
                    -- Incremental: load current and last period only
                    ELSE 
                        CASE WHEN (TD.BOEKJR = @LastPeriodYear AND TD.PERIODE = @LastPeriode)
                               OR (TD.BOEKJR = @CurrentYear AND TD.PERIODE = @CurrentPeriode) THEN 1 ELSE 0 END
                END = 1
        ) AS source 
        ON target.System = 'FINACC' 
        AND target.Table_Name = 'TAANDAGD' 
        AND target.F_ID = source.F_ID
        
        -- Update existing records
        WHEN MATCHED THEN UPDATE SET
            Amount = source.Amount,
            [Balance/Cost Group] = source.[Balance/Cost Group],
            [Cost_Center] = source.[Cost_Center],
            Source = source.Source,
            [Date] = source.[Date],
            [JE Description] = source.[JE Description],
            [Entity System Code] = source.[Entity System Code],
            [GL_Account] = source.[GL_Account],
            [Posted By] = source.[Posted By],
            [Posted Time] = source.[Posted Time],
            [Posted Date] = source.[Posted Date],
            [Period] = source.[Period],
            [Vendor Name] = source.[Vendor Name],
            [Vendor Number] = source.[Vendor Number],
            [Transaction Number] = source.[Transaction Number],
            [Entity Code] = source.[Entity Code],
            [Entity Description] = source.[Entity Description],
            [GL Account Description] = source.[GL Account Description],
            [Lineage_Key] = source.[Lineage_Key],
            Lineage_Key_Origin = source.Lineage_Key_Origin,
            [GL_Table_Key] = source.[GL_Table_Key],
            [Entity_Table_Key] = source.[Entity_Table_Key],
            Fiscal_Year = source.Fiscal_Year
            
        -- Insert new records
        WHEN NOT MATCHED BY TARGET THEN INSERT (
            [System],
            [Date],
            [Period],
            [Entity System Code],
            [GL_Account],
            [JE Description],
            Amount,
            Source,
            [Cost_Center],
            [Cost_Center_Description],
            [Cost_Center2],
            [Cost_Center_Description2],
            [Cost_Center3],
            [Cost_Center_Description3],
            [Transaction Number],
            [Balance/Cost Group],
            [Posted Time],
            [Posted By],
            [Posted Date],
            [Fiscal_Year],
            [Vendor Number],
            [Vendor Name],
            [Lineage_Key],
            Lineage_Key_Origin,
            [GL_Table_Key],
            [Entity_Table_Key],
            RECID,
            [Entity Code],
            [Entity Description],
            [GL Account Description],
            Table_Name,
            F_ID
        )
        VALUES (
            source.[System],
            source.[Date],
            source.[Period],
            source.[Entity System Code],
            source.[GL_Account],
            source.[JE Description],
            source.Amount,
            source.Source,
            source.[Cost_Center],
            source.[Cost_Center_Description],
            source.[Cost_Center2],
            source.[Cost_Center_Description2],
            source.[Cost_Center3],
            source.[Cost_Center_Description3],
            source.[Transaction Number],
            source.[Balance/Cost Group],
            source.[Posted Time],
            source.[Posted By],
            source.[Posted Date],
            source.Fiscal_Year,
            source.[Vendor Number],
            source.[Vendor Name],
            source.[Lineage_Key],
            source.Lineage_Key_Origin,
            source.[GL_Table_Key],
            source.[Entity_Table_Key],
            source.RECID,
            source.[Entity Code],
            source.[Entity Description],
            source.[GL Account Description],
            source.Table_Name,
            source.F_ID
        )
        
        -- Delete records no longer in source (for specified periods)
        WHEN NOT MATCHED BY SOURCE 
            AND target.System = 'FINACC' 
            AND target.Table_Name = 'TAANDAGD'
            AND (
                (@LoadType = 'F' AND target.Fiscal_Year IN (@CurrentYear, @PreviousYear))
                OR 
                (@LoadType = 'I' AND (
                    (target.Fiscal_Year = @LastPeriodYear AND target.[Period] = @LastPeriodYear * 100 + @LastPeriode)
                    OR (target.Fiscal_Year = @CurrentYear AND target.[Period] = @CurrentYear * 100 + @CurrentPeriode)
                ))
            )
        THEN DELETE
        
        -- Capture what happened
        OUTPUT $action INTO #MergeOutput(ActionType);
        
        -- Get the counts
        SELECT 
            @RowsInserted = COUNT(CASE WHEN ActionType = 'INSERT' THEN 1 END),
            @RowsUpdated = COUNT(CASE WHEN ActionType = 'UPDATE' THEN 1 END),
            @RowsDeleted = COUNT(CASE WHEN ActionType = 'DELETE' THEN 1 END)
        FROM #MergeOutput;
        
        SET @RowCount = @RowsInserted + @RowsUpdated + @RowsDeleted;
        
        -- Clean up temp table
        DROP TABLE #MergeOutput;
        
        COMMIT TRANSACTION;
        
        -- Build success message
        IF @LoadType = 'F'
            SET @OutputMessage = CONCAT(
                'GL Transactions FINACC Full Load completed. ',
                'Years: ', @PreviousYear, ' and ', @CurrentYear,
                ' | Rows affected: ', @RowCount,
                ' (Inserted: ', @RowsInserted,
                ', Updated: ', @RowsUpdated,
                ', Deleted: ', @RowsDeleted, ')'
            );
        ELSE
            SET @OutputMessage = CONCAT(
                'GL Transactions FINACC Incremental Load completed. ',
                'Current Period: ', @CurrentYear, '-', @CurrentPeriode,
                ', Last Period: ', @LastPeriodYear, '-', @LastPeriode,
                ' | Rows affected: ', @RowCount,
                ' (Inserted: ', @RowsInserted,
                ', Updated: ', @RowsUpdated,
                ', Deleted: ', @RowsDeleted, ')'
            );
        
        -- Return results for lineage tracking
        SELECT @RowCount AS [RowCount], @OutputMessage AS OutputMessage;
        
        PRINT @OutputMessage;
        RETURN 0;
        
    END TRY
    BEGIN CATCH
        IF @@TRANCOUNT > 0
            ROLLBACK TRANSACTION;
        
        -- Clean up temp table if exists
        IF OBJECT_ID('tempdb..#MergeOutput') IS NOT NULL
            DROP TABLE #MergeOutput;
        
        -- Capture error details
        DECLARE @ErrorMessage NVARCHAR(4000) = ERROR_MESSAGE();
        DECLARE @ErrorNumber INT = ERROR_NUMBER();
        DECLARE @ErrorSeverity INT = ERROR_SEVERITY();
        DECLARE @ErrorState INT = ERROR_STATE();
        DECLARE @ErrorLine INT = ERROR_LINE();
        
        -- Build error message
        SET @OutputMessage = CONCAT(
            'Error ', @ErrorNumber,
            ' at line ', @ErrorLine, ': ', @ErrorMessage
        );
        
        -- Return error for lineage tracking
        SET @RowCount = 0;
        SELECT @RowCount AS [RowCount], @OutputMessage AS OutputMessage;
        
        -- Log error for debugging
        PRINT @OutputMessage;
        
        RETURN -1;
    END CATCH
END;
GO
/****** Object:  StoredProcedure [dbo].[Load_GL_Transactions_FINACC_TALGDAGB]    Script Date: 27-8-2025 13:37:43 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE   PROCEDURE [dbo].[Load_GL_Transactions_FINACC_TALGDAGB]
    @LineageKey INT,
    @LoadType CHAR(1) = 'I',  -- F=Full, I=Incremental
    @LastLoadDate DATETIME2(7) = NULL
AS
BEGIN
    SET NOCOUNT ON;
    SET XACT_ABORT ON;
    
    -- Variables for tracking results
    DECLARE @RowCount INT = 0;
    DECLARE @RowsInserted INT = 0;
    DECLARE @RowsUpdated INT = 0;
    DECLARE @RowsDeleted INT = 0;
    DECLARE @OutputMessage NVARCHAR(MAX);
    DECLARE @System NVARCHAR(25) = 'FINACC';
    DECLARE @TableName NVARCHAR(100) = 'GL_Transactions_FINACC_TALGDAGB';
    
    -- Batch processing variables
    DECLARE @BatchSize INT = 100000;
    DECLARE @CurrentRow INT;
    DECLARE @MaxRow INT;
    DECLARE @DeleteRowCount INT = 1;
    
    BEGIN TRY
        
        BEGIN TRANSACTION;
        
        -- Get the MIN and MAX ID from TALGDAGB for batch processing
        SELECT @CurrentRow = MIN(ID), @MaxRow = MAX(ID)
        FROM [STAGING_FINACC].dbo.TALGDAGB
        WHERE @LoadType = 'F' OR CREA >= @LastLoadDate;
        
        -- Delete old data for incremental load (in batches to avoid lock escalation)
        IF @LoadType = 'I' AND @LastLoadDate IS NOT NULL
        BEGIN
            WHILE @DeleteRowCount > 0
            BEGIN
                DELETE TOP (@BatchSize)
                FROM [dbo].[GL_Transactions]
                WHERE [Posted Date] >= @LastLoadDate 
                AND [System] = 'FINACC'
                AND [Table_Name] = 'TALGDAGB';
                
                SET @DeleteRowCount = @@ROWCOUNT;
                SET @RowsDeleted = @RowsDeleted + @DeleteRowCount;
            END;
        END
        ELSE IF @LoadType = 'F'
        BEGIN
            -- For full load, delete all FINACC TALGDAGB records
            DELETE FROM [dbo].[GL_Transactions]
            WHERE [System] = 'FINACC'
            AND [Table_Name] = 'TALGDAGB';
            
            SET @RowsDeleted = @@ROWCOUNT;
        END
        
        -- Insert new data in batches
        WHILE @CurrentRow <= @MaxRow
        BEGIN
            INSERT INTO [dbo].[GL_Transactions] WITH (TABLOCKX) (
                [System],
                [Date],
                [Period],
                [Entity System Code],
                [GL_Account],
                [JE Description],
                [Amount],
                [Source],
                [Cost_Center],
                [Cost_Center_Description],
                [Cost_Center2],
                [Cost_Center_Description2],
                [Cost_Center3],
                [Cost_Center_Description3],
                [Transaction Number],
                [Balance/Cost Group],
                [Posted Time],
                [Posted By],
                [Posted Date],
                [Fiscal_Year],
                [Vendor Number],
                [Vendor Name],
                [Lineage_Key],
                [Lineage_Key_Origin],
                [GL_Table_Key],
                [Entity_Table_Key],
                [RECID],
                [Entity Code],
                [Entity Description],
                [GL Account Description],
                [Table_Name],
                [F_ID]
            )
            SELECT
                'FINACC' AS [System],
                CAST(CASE 
                    WHEN MONTH(TD.VERRDAT) <> TD.PERIODE OR YEAR(TD.VERRDAT) <> TD.BOEKJR
                    THEN EOMONTH(DATEFROMPARTS(TD.BOEKJR, IIF(TD.PERIODE = 0, 1, TD.PERIODE), 1))
                    ELSE TD.VERRDAT 
                END AS DATE) AS [Date],
                TD.BOEKJR * 100 + TD.PERIODE AS [Period],
                TD.FIRKODE AS [Entity System Code],
                CAST(TD.ALGREK AS NVARCHAR(20)) AS [GL_Account],
                TD.OPM AS [JE Description],
                TD.BEDR AS [Amount],
                CONCAT(TD.TYPE, ' / ', TD.DAGBOEK) AS [Source],
                TC.KOSTPL2 AS [Cost_Center],
                NULL AS [Cost_Center_Description],
                NULL AS [Cost_Center2],
                NULL AS [Cost_Center_Description2],
                NULL AS [Cost_Center3],
                NULL AS [Cost_Center_Description3],
                TD.VERRNR AS [Transaction Number],
                COALESCE(T.KOSTSRT, T.BALGRPPAS, T.BALGRPAKT) AS [Balance/Cost Group],
                CAST(TD.WYZ AS DATETIME2) AS [Posted Time],
                TD.USCREA AS [Posted By],
                CAST(TD.WYZ AS DATE) AS [Posted Date],
                TD.BOEKJR AS [Fiscal_Year],
                L.LEVERNR AS [Vendor Number],
                L.NAAM AS [Vendor Name],
                @LineageKey AS [Lineage_Key],
                TD.Lineage_Key AS [Lineage_Key_Origin],
                L2.GL_Table_Key,
                e.Entity_Table_Key,
                NULL AS [RECID],  -- FINACC doesn't use RECID
                e.[Entity Code],
                e.[Entity Description],
                L2.[GL Account Description],
                'TALGDAGB' AS [Table_Name],
                TD.ID AS [F_ID]
            FROM [STAGING_FINACC].dbo.TALGDAGB TD WITH (TABLOCK)
            LEFT JOIN [STAGING_FINACC].dbo.TALGREK T WITH (TABLOCK)
                ON T.BOEKJR = TD.BOEKJR 
                AND T.FIRKODE = TD.FIRKODE 
                AND T.ALGREK = TD.ALGREK
            LEFT JOIN [STAGING_FINACC].dbo.TLEVER L WITH (TABLOCK)
                ON L.LEVERNR = TD.LEVERNR 
                AND L.FIRKODE = TD.FIRKODE
            LEFT JOIN STAGING_FINACC.dbo.TAN_DET TAND WITH (TABLOCK)
                ON TAND.BEDRAG = TD.BEDR 
                AND TAND.FIRKODE = TD.FIRKODE 
                AND TAND.BOEKJR = TD.BOEKJR 
                AND TAND.PERIODE = TD.PERIODE 
                AND TAND.VERRNR = TD.VERRNR 
                AND TAND.VERRVOLGNR = TD.VOLGNR 
                AND TAND.VNALGREK = TD.ALGREK
            LEFT JOIN STAGING_FINACC.dbo.TAN_COMBH TC WITH (TABLOCK)
                ON TC.SEQ = TAND.NRSEQ 
                AND TC.FIRKODE = TAND.FIRKODE
            LEFT JOIN [DWH_FINANCE].dbo.GL_Table L2 WITH (TABLOCK)
                ON L2.System = 'FINACC' 
                AND L2.[Entity System Code] = TD.FIRKODE 
                AND L2.[GL Account] = CAST(TD.ALGREK AS NVARCHAR(20))
                AND L2.BOEKJR = TD.BOEKJR
            INNER JOIN [DWH_FINANCE].dbo.Entity e WITH (TABLOCK)
                ON e.System = 'FINACC' 
                AND e.[Entity System Code] = TD.FIRKODE
            WHERE TD.ID BETWEEN @CurrentRow AND @CurrentRow + @BatchSize - 1 
                AND TD.DAGBOEK NOT IN ('CAAN','CVER')  -- Exclude specific journal types
                AND (
                    -- For incremental: use date filter
                    (@LoadType = 'I' AND TD.CREA >= @LastLoadDate)
                    OR 
                    -- For full load: no date filter
                    (@LoadType = 'F')
                );
            
            SET @RowsInserted = @RowsInserted + @@ROWCOUNT;
            
            -- Move to next batch
            SET @CurrentRow = @CurrentRow + @BatchSize;
            
            -- Check if there are more rows to process
            IF NOT EXISTS (
                SELECT 1 FROM [STAGING_FINACC].dbo.TALGDAGB 
                WHERE ID >= @CurrentRow
                AND (@LoadType = 'F' OR CREA >= @LastLoadDate)
            )
                BREAK;
        END;
        
        SET @RowCount = @RowsInserted;
        
        COMMIT TRANSACTION;
        
        -- Build success message
        SET @OutputMessage = CONCAT(
            'GL Transactions FINACC TALGDAGB load completed. ',
            'Type: ', CASE WHEN @LoadType = 'F' THEN 'Full' ELSE 'Incremental' END,
            ' | From: ', CONVERT(VARCHAR(30), @LastLoadDate, 120),
            ' | Rows affected: ', @RowCount,
            ' (Inserted: ', @RowsInserted,
            ', Deleted: ', @RowsDeleted, ')',
            ' | Batch size: ', @BatchSize,
            ' | Excluded journals: CAAN, CVER'
        );
        
        -- Return results for lineage tracking
        SELECT @RowCount AS [RowCount], @OutputMessage AS OutputMessage;
        
        PRINT @OutputMessage;
        RETURN 0;
        
    END TRY
    BEGIN CATCH
        IF @@TRANCOUNT > 0
            ROLLBACK TRANSACTION;
        
        -- Capture error details
        DECLARE @ErrorMessage NVARCHAR(4000) = ERROR_MESSAGE();
        DECLARE @ErrorNumber INT = ERROR_NUMBER();
        DECLARE @ErrorSeverity INT = ERROR_SEVERITY();
        DECLARE @ErrorState INT = ERROR_STATE();
        DECLARE @ErrorLine INT = ERROR_LINE();
        
        -- Build error message
        SET @OutputMessage = CONCAT(
            'Error ', @ErrorNumber,
            ' at line ', @ErrorLine, ': ', @ErrorMessage
        );
        
        -- Return error for lineage tracking
        SET @RowCount = 0;
        SELECT @RowCount AS [RowCount], @OutputMessage AS OutputMessage;
        
        -- Log error for debugging
        PRINT @OutputMessage;
        
        RETURN -1;
    END CATCH
END;
GO
/****** Object:  StoredProcedure [dbo].[Load_GL_Transactions_FINACC_TFINDAGB]    Script Date: 27-8-2025 13:37:43 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE   PROCEDURE [dbo].[Load_GL_Transactions_FINACC_TFINDAGB]
    @LineageKey INT,
    @LoadType CHAR(1) = 'I',  -- F=Full, I=Incremental
    @LastLoadDate DATETIME2(7) = NULL
AS
BEGIN
    SET NOCOUNT ON;
    SET XACT_ABORT ON;
    
    -- Variables for tracking results
    DECLARE @RowCount INT = 0;
    DECLARE @RowsInserted INT = 0;
    DECLARE @RowsUpdated INT = 0;
    DECLARE @RowsDeleted INT = 0;
    DECLARE @OutputMessage NVARCHAR(MAX);
    DECLARE @System NVARCHAR(25) = 'FINACC';
    DECLARE @TableName NVARCHAR(100) = 'GL_Transactions_FINACC_TFINDAGB';
    
    -- Batch processing variables
    DECLARE @BatchSize INT = 100000;
    DECLARE @CurrentRow INT;
    DECLARE @MaxRow INT;
    DECLARE @DeleteRowCount INT = 1;
    
    BEGIN TRY
        
        BEGIN TRANSACTION;
        
        -- Get the MIN and MAX ID from TFINDAGB for batch processing
        SELECT @CurrentRow = MIN(ID), @MaxRow = MAX(ID)
        FROM [STAGING_FINACC].dbo.TFINDAGB
        WHERE @LoadType = 'F' OR WYZ >= @LastLoadDate;
        
        -- Delete old data for incremental load (in batches to avoid lock escalation)
        IF @LoadType = 'I' AND @LastLoadDate IS NOT NULL
        BEGIN
            WHILE @DeleteRowCount > 0
            BEGIN
                DELETE TOP (@BatchSize)
                FROM [dbo].[GL_Transactions]
                WHERE [Posted Date] >= @LastLoadDate 
                AND [System] = 'FINACC'
                AND [Table_Name] = 'TFINDAGB';
                
                SET @DeleteRowCount = @@ROWCOUNT;
                SET @RowsDeleted = @RowsDeleted + @DeleteRowCount;
            END;
        END
        ELSE IF @LoadType = 'F'
        BEGIN
            -- For full load, delete all FINACC TFINDAGB records
            DELETE FROM [dbo].[GL_Transactions]
            WHERE [System] = 'FINACC'
            AND [Table_Name] = 'TFINDAGB';
            
            SET @RowsDeleted = @@ROWCOUNT;
        END
        
        -- Insert new data in batches
        WHILE @CurrentRow <= @MaxRow
        BEGIN
            INSERT INTO [dbo].[GL_Transactions] (
                [System],
                [Date],
                [Period],
                [Entity System Code],
                [GL_Account],
                [JE Description],
                [Amount],
                [Source],
                [Cost_Center],
                [Cost_Center_Description],
                [Cost_Center2],
                [Cost_Center_Description2],
                [Cost_Center3],
                [Cost_Center_Description3],
                [Transaction Number],
                [Balance/Cost Group],
                [Posted Time],
                [Posted By],
                [Posted Date],
                [Fiscal_Year],
                [Vendor Number],
                [Vendor Name],
                [Lineage_Key],
                [Lineage_Key_Origin],
                [GL_Table_Key],
                [Entity_Table_Key],
                [RECID],
                [Entity Code],
                [Entity Description],
                [GL Account Description],
                [Table_Name],
                [F_ID]
            )
            SELECT
                'FINACC' AS [System],
                CAST(CASE 
                    WHEN MONTH(TD.DATUM) <> TD.PERIODE OR YEAR(TD.DATUM) <> TD.BOEKJR
                    THEN EOMONTH(DATEFROMPARTS(TD.BOEKJR, IIF(TD.PERIODE = 0, 1, TD.PERIODE), 1))
                    ELSE TD.DATUM 
                END AS DATE) AS [Date],
                TD.BOEKJR * 100 + TD.PERIODE AS [Period],
                TD.FIRKODE AS [Entity System Code],
                CAST(TD.ALGREK AS NVARCHAR(20)) AS [GL_Account],
                TD.OPMERK AS [JE Description],
                TD.BEDRAG_MNTBKH AS [Amount],  -- Note: Different field name than other tables
                CONCAT(TD.TYPE_DAGB, ' / ', TD.DAGBOEK) AS [Source],
                TC.KOSTPL2 AS [Cost_Center],
                NULL AS [Cost_Center_Description],
                NULL AS [Cost_Center2],
                NULL AS [Cost_Center_Description2],
                NULL AS [Cost_Center3],
                NULL AS [Cost_Center_Description3],
                TD.VERRNR AS [Transaction Number],
                COALESCE(T.KOSTSRT, T.BALGRPPAS, T.BALGRPAKT) AS [Balance/Cost Group],
                CAST(TD.WYZ AS DATETIME2) AS [Posted Time],
                TD.USCREA AS [Posted By],
                CAST(TD.WYZ AS DATE) AS [Posted Date],
                TD.BOEKJR AS [Fiscal_Year],
                L.LEVERNR AS [Vendor Number],
                L.NAAM AS [Vendor Name],
                @LineageKey AS [Lineage_Key],
                TD.Lineage_Key AS [Lineage_Key_Origin],
                L2.GL_Table_Key,
                e.Entity_Table_Key,
                NULL AS [RECID],  -- FINACC doesn't use RECID
                e.[Entity Code],
                e.[Entity Description],
                L2.[GL Account Description],
                'TFINDAGB' AS [Table_Name],
                TD.ID AS [F_ID]
            FROM [STAGING_FINACC].dbo.TFINDAGB TD
            LEFT JOIN [STAGING_FINACC].dbo.TALGREK T 
                ON T.BOEKJR = TD.BOEKJR 
                AND T.FIRKODE = TD.FIRKODE 
                AND T.ALGREK = TD.ALGREK
            LEFT JOIN [STAGING_FINACC].dbo.TLEVER L 
                ON L.LEVERNR = TD.LEVERNR 
                AND L.FIRKODE = TD.FIRKODE
            LEFT JOIN STAGING_FINACC.dbo.TAN_DET TAND
                ON TAND.BEDRAG = TD.BEDRAG_MNTBKH  -- Note: Matching on BEDRAG_MNTBKH
                AND TAND.FIRKODE = TD.FIRKODE 
                AND TAND.BOEKJR = TD.BOEKJR 
                AND TAND.PERIODE = TD.PERIODE 
                AND TAND.VERRNR = TD.VERRNR 
                AND TAND.VERRVOLGNR = TD.VOLGNR 
                AND TAND.VNALGREK = TD.ALGREK
            LEFT JOIN STAGING_FINACC.dbo.TAN_COMBH TC
                ON TC.SEQ = TAND.NRSEQ 
                AND TC.FIRKODE = TAND.FIRKODE
            LEFT JOIN [DWH_FINANCE].dbo.GL_Table L2 
                ON L2.System = 'FINACC' 
                AND L2.[Entity System Code] = TD.FIRKODE 
                AND L2.[GL Account] = CAST(TD.ALGREK AS NVARCHAR(20))
                AND L2.BOEKJR = TD.BOEKJR
            INNER JOIN [DWH_FINANCE].dbo.Entity e 
                ON e.System = 'FINACC' 
                AND e.[Entity System Code] = TD.FIRKODE
            WHERE TD.ID BETWEEN @CurrentRow AND @CurrentRow + @BatchSize - 1
                AND (
                    -- For incremental: use date filter
                    (@LoadType = 'I' AND TD.WYZ >= @LastLoadDate)
                    OR 
                    -- For full load: no date filter
                    (@LoadType = 'F')
                );
            
            SET @RowsInserted = @RowsInserted + @@ROWCOUNT;
            
            -- Move to next batch
            SET @CurrentRow = @CurrentRow + @BatchSize;
            
            -- Check if there are more rows to process
            IF NOT EXISTS (
                SELECT 1 FROM [STAGING_FINACC].dbo.TFINDAGB 
                WHERE ID >= @CurrentRow
                AND (@LoadType = 'F' OR WYZ >= @LastLoadDate)
            )
                BREAK;
        END;
        
        SET @RowCount = @RowsInserted;
        
        COMMIT TRANSACTION;
        
        -- Build success message
        SET @OutputMessage = CONCAT(
            'GL Transactions FINACC TFINDAGB load completed. ',
            'Type: ', CASE WHEN @LoadType = 'F' THEN 'Full' ELSE 'Incremental' END,
            ' | From: ', CONVERT(VARCHAR(30), @LastLoadDate, 120),
            ' | Rows affected: ', @RowCount,
            ' (Inserted: ', @RowsInserted,
            ', Deleted: ', @RowsDeleted, ')',
            ' | Batch size: ', @BatchSize
        );
        
        -- Return results for lineage tracking
        SELECT @RowCount AS [RowCount], @OutputMessage AS OutputMessage;
        
        PRINT @OutputMessage;
        RETURN 0;
        
    END TRY
    BEGIN CATCH
        IF @@TRANCOUNT > 0
            ROLLBACK TRANSACTION;
        
        -- Capture error details
        DECLARE @ErrorMessage NVARCHAR(4000) = ERROR_MESSAGE();
        DECLARE @ErrorNumber INT = ERROR_NUMBER();
        DECLARE @ErrorSeverity INT = ERROR_SEVERITY();
        DECLARE @ErrorState INT = ERROR_STATE();
        DECLARE @ErrorLine INT = ERROR_LINE();
        
        -- Build error message
        SET @OutputMessage = CONCAT(
            'Error ', @ErrorNumber,
            ' at line ', @ErrorLine, ': ', @ErrorMessage
        );
        
        -- Return error for lineage tracking
        SET @RowCount = 0;
        SELECT @RowCount AS [RowCount], @OutputMessage AS OutputMessage;
        
        -- Log error for debugging
        PRINT @OutputMessage;
        
        RETURN -1;
    END CATCH
END;
GO
/****** Object:  StoredProcedure [dbo].[Load_GL_Transactions_FINACC_TVERDAGD]    Script Date: 27-8-2025 13:37:43 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE   PROCEDURE [dbo].[Load_GL_Transactions_FINACC_TVERDAGD]
    @LineageKey INT,
    @LoadType CHAR(1) = 'I',  -- F=Full, I=Incremental
    @LastLoadDate DATETIME2(7) = NULL
AS
BEGIN
    SET NOCOUNT ON;
    SET XACT_ABORT ON;
    
    -- Variables for tracking results
    DECLARE @RowCount INT = 0;
    DECLARE @RowsInserted INT = 0;
    DECLARE @RowsUpdated INT = 0;
    DECLARE @RowsDeleted INT = 0;
    DECLARE @OutputMessage NVARCHAR(MAX);
    DECLARE @System NVARCHAR(25) = 'FINACC';
    DECLARE @TableName NVARCHAR(100) = 'GL_Transactions_FINACC_TVERDAGD';
    
    -- Batch processing variables
    DECLARE @BatchSize INT = 100000;
    DECLARE @CurrentRow INT;
    DECLARE @MaxRow INT;
    DECLARE @DeleteRowCount INT = 1;
    
    BEGIN TRY
        
        BEGIN TRANSACTION;
        
        -- Get the MIN and MAX ID from TVERDAGD for batch processing
        SELECT @CurrentRow = MIN(ID), @MaxRow = MAX(ID)
        FROM [STAGING_FINACC].dbo.TVERDAGD
        WHERE @LoadType = 'F' OR WYZ >= @LastLoadDate;
        
        -- Delete old data for incremental load (in batches to avoid lock escalation)
        IF @LoadType = 'I' AND @LastLoadDate IS NOT NULL
        BEGIN
            WHILE @DeleteRowCount > 0
            BEGIN
                DELETE TOP (@BatchSize)
                FROM [dbo].[GL_Transactions]
                WHERE [Posted Date] >= @LastLoadDate 
                AND [System] = 'FINACC'
                AND [Table_Name] = 'TVERDAGD';
                
                SET @DeleteRowCount = @@ROWCOUNT;
                SET @RowsDeleted = @RowsDeleted + @DeleteRowCount;
            END;
        END
        ELSE IF @LoadType = 'F'
        BEGIN
            -- For full load, delete all FINACC TVERDAGD records
            DELETE FROM [dbo].[GL_Transactions]
            WHERE [System] = 'FINACC'
            AND [Table_Name] = 'TVERDAGD';
            
            SET @RowsDeleted = @@ROWCOUNT;
        END
        
        -- Insert new data in batches
        WHILE @CurrentRow <= @MaxRow
        BEGIN
            INSERT INTO [dbo].[GL_Transactions] (
                [System],
                [Date],
                [Period],
                [Entity System Code],
                [GL_Account],
                [JE Description],
                [Amount],
                [Source],
                [Cost_Center],
                [Cost_Center_Description],
                [Cost_Center2],
                [Cost_Center_Description2],
                [Cost_Center3],
                [Cost_Center_Description3],
                [Transaction Number],
                [Balance/Cost Group],
                [Posted Time],
                [Posted By],
                [Posted Date],
                [Fiscal_Year],
                [Vendor Number],
                [Vendor Name],
                [Lineage_Key],
                [Lineage_Key_Origin],
                [GL_Table_Key],
                [Entity_Table_Key],
                [RECID],
                [Entity Code],
                [Entity Description],
                [GL Account Description],
                [Table_Name],
                [F_ID]
            )
            SELECT
                'FINACC' AS [System],
                CAST(CASE 
                    WHEN MONTH(TD.DATUM) <> TD.PERIODE OR YEAR(TD.DATUM) <> TD.BOEKJR
                    THEN EOMONTH(DATEFROMPARTS(TD.BOEKJR, IIF(TD.PERIODE = 0, 1, TD.PERIODE), 1))
                    ELSE TD.DATUM 
                END AS DATE) AS [Date],
                TD.BOEKJR * 100 + TD.PERIODE AS [Period],
                TD.FIRKODE AS [Entity System Code],
                CAST(TD.ALGREK AS NVARCHAR(20)) AS [GL_Account],
                TD.OPMERK AS [JE Description],
                TD.BEDRAG AS [Amount],  -- Standard BEDRAG field for this table
                CONCAT(TD.TYPE_DAGB, ' / ', TD.DAGBOEK) AS [Source],
                TC.KOSTPL2 AS [Cost_Center],
                NULL AS [Cost_Center_Description],
                NULL AS [Cost_Center2],
                NULL AS [Cost_Center_Description2],
                NULL AS [Cost_Center3],
                NULL AS [Cost_Center_Description3],
                TD.FAKTNR AS [Transaction Number],  -- Note: FAKTNR instead of VERRNR
                COALESCE(T.KOSTSRT, T.BALGRPPAS, T.BALGRPAKT) AS [Balance/Cost Group],
                CAST(TD.WYZ AS DATETIME2) AS [Posted Time],
                TD.USCREA AS [Posted By],
                CAST(TD.WYZ AS DATE) AS [Posted Date],
                TD.BOEKJR AS [Fiscal_Year],
                L.LEVERNR AS [Vendor Number],
                L.NAAM AS [Vendor Name],
                @LineageKey AS [Lineage_Key],
                TD.Lineage_Key AS [Lineage_Key_Origin],
                L2.GL_Table_Key,
                e.Entity_Table_Key,
                NULL AS [RECID],  -- FINACC doesn't use RECID
                e.[Entity Code],
                e.[Entity Description],
                L2.[GL Account Description],
                'TVERDAGD' AS [Table_Name],
                TD.ID AS [F_ID]
            FROM [STAGING_FINACC].dbo.TVERDAGD TD
            LEFT JOIN [STAGING_FINACC].dbo.TALGREK T 
                ON T.BOEKJR = TD.BOEKJR 
                AND T.FIRKODE = TD.FIRKODE 
                AND T.ALGREK = TD.ALGREK
            LEFT JOIN [STAGING_FINACC].dbo.TLEVER L 
                ON L.LEVERNR = TD.REL_LEVERNR  -- Note: REL_LEVERNR for this table
                AND L.FIRKODE = TD.FIRKODE
            LEFT JOIN STAGING_FINACC.dbo.TAN_DET TAND
                ON TAND.BEDRAG = TD.BEDRAG 
                AND TAND.FIRKODE = TD.FIRKODE 
                AND TAND.BOEKJR = TD.BOEKJR 
                AND TAND.PERIODE = TD.PERIODE 
                AND TAND.VERRNR = TD.FAKTNR  -- Using FAKTNR for VERRNR join
                AND TAND.VERRVOLGNR = TD.VOLGNR 
                AND TAND.VNALGREK = TD.ALGREK
            LEFT JOIN STAGING_FINACC.dbo.TAN_COMBH TC
                ON TC.SEQ = TAND.NRSEQ 
                AND TC.FIRKODE = TAND.FIRKODE
            LEFT JOIN [DWH_FINANCE].dbo.GL_Table L2 
                ON L2.System = 'FINACC' 
                AND L2.[Entity System Code] = TD.FIRKODE 
                AND L2.[GL Account] = CAST(TD.ALGREK AS NVARCHAR(20))
                AND L2.BOEKJR = TD.BOEKJR
            INNER JOIN [DWH_FINANCE].dbo.Entity e 
                ON e.System = 'FINACC' 
                AND e.[Entity System Code] = TD.FIRKODE
            WHERE TD.ID BETWEEN @CurrentRow AND @CurrentRow + @BatchSize - 1
                AND (
                    -- For incremental: use date filter
                    (@LoadType = 'I' AND TD.WYZ >= @LastLoadDate)
                    OR 
                    -- For full load: no date filter
                    (@LoadType = 'F')
                );
            
            SET @RowsInserted = @RowsInserted + @@ROWCOUNT;
            
            -- Move to next batch
            SET @CurrentRow = @CurrentRow + @BatchSize;
            
            -- Check if there are more rows to process
            IF NOT EXISTS (
                SELECT 1 FROM [STAGING_FINACC].dbo.TVERDAGD 
                WHERE ID >= @CurrentRow
                AND (@LoadType = 'F' OR WYZ >= @LastLoadDate)
            )
                BREAK;
        END;
        
        SET @RowCount = @RowsInserted;
        
        COMMIT TRANSACTION;
        
        -- Build success message
        SET @OutputMessage = CONCAT(
            'GL Transactions FINACC TVERDAGD load completed. ',
            'Type: ', CASE WHEN @LoadType = 'F' THEN 'Full' ELSE 'Incremental' END,
            ' | From: ', CONVERT(VARCHAR(30), @LastLoadDate, 120),
            ' | Rows affected: ', @RowCount,
            ' (Inserted: ', @RowsInserted,
            ', Deleted: ', @RowsDeleted, ')',
            ' | Batch size: ', @BatchSize
        );
        
        -- Return results for lineage tracking
        SELECT @RowCount AS [RowCount], @OutputMessage AS OutputMessage;
        
        PRINT @OutputMessage;
        RETURN 0;
        
    END TRY
    BEGIN CATCH
        IF @@TRANCOUNT > 0
            ROLLBACK TRANSACTION;
        
        -- Capture error details
        DECLARE @ErrorMessage NVARCHAR(4000) = ERROR_MESSAGE();
        DECLARE @ErrorNumber INT = ERROR_NUMBER();
        DECLARE @ErrorSeverity INT = ERROR_SEVERITY();
        DECLARE @ErrorState INT = ERROR_STATE();
        DECLARE @ErrorLine INT = ERROR_LINE();
        
        -- Build error message
        SET @OutputMessage = CONCAT(
            'Error ', @ErrorNumber,
            ' at line ', @ErrorLine, ': ', @ErrorMessage
        );
        
        -- Return error for lineage tracking
        SET @RowCount = 0;
        SELECT @RowCount AS [RowCount], @OutputMessage AS OutputMessage;
        
        -- Log error for debugging
        PRINT @OutputMessage;
        
        RETURN -1;
    END CATCH
END;
GO
/****** Object:  StoredProcedure [dbo].[Load_MDS_Cognos_Accounts]    Script Date: 27-8-2025 13:37:43 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE   PROCEDURE [dbo].[Load_MDS_Cognos_Accounts]
    @LineageKey INT,
    @LoadType CHAR(1) = 'F',  -- F=Full, I=Incremental
    @LastLoadDate DATETIME2(7) = NULL
AS
BEGIN
    SET NOCOUNT ON;
    SET XACT_ABORT ON;
    
    -- Declare variables
    DECLARE @RowCount BIGINT = 0;
    DECLARE @RowsInserted BIGINT = 0;
    DECLARE @RowsUpdated BIGINT = 0;
    DECLARE @RowsDeleted BIGINT = 0;
    DECLARE @OutputMessage NVARCHAR(MAX);
    DECLARE @ErrorNumber INT;
    DECLARE @ErrorSeverity INT;
    DECLARE @ErrorState INT;
    DECLARE @StartTime DATETIME2(7) = SYSDATETIME();
    DECLARE @EndTime DATETIME2(7);
    
    BEGIN TRY
        BEGIN TRANSACTION;
        
        -- Validate LineageKey
        IF NOT EXISTS (SELECT 1 FROM [exe].[Lineage] WHERE [Lineage_Key] = @LineageKey)
        BEGIN
            RAISERROR('Invalid LineageKey: %d', 16, 1, @LineageKey);
            RETURN -1;
        END
        
        -- For incremental loads, get last load date if not provided
        IF @LoadType = 'I' AND @LastLoadDate IS NULL
        BEGIN
            SELECT @LastLoadDate = [Last_Loaded_Date]
            FROM [exe].[Lineage]
            WHERE [Lineage_Key] = @LineageKey;
        END
        
        -- FULL LOAD LOGIC (your existing logic)
        IF @LoadType = 'F'
        BEGIN
            -- Truncate target table
            TRUNCATE TABLE [dbo].[Cognos Accounts];
            
            -- Insert all data from MDS
            INSERT INTO [dbo].[Cognos Accounts] (
                [Description Cognos accts],
                [GL Account],
                [Entity System Code],
                [Entity Code],
                [Balance/Cost Group],
                [Cognos_Account],
                [System],
                [Counterparty Code],
                [Counterparty Name],
                [Lineage_Key]
            )
            SELECT 
                [Description Cognos accts],
                [GL Account],
                [Entity System Code],
                [Entity Code],
                [Balance/Cost Group],
                [Cognos Account],
                [System],	  
                [Counterparty Code],
                [Counterparty Name],
                @LineageKey
            FROM [SCH1SQL1V16].[STAGING_MDS].[dbo].[Cognos Accounts];
            
            SET @RowsInserted = @@ROWCOUNT;
            SET @RowCount = @RowsInserted;
        END
        
        -- INCREMENTAL LOAD LOGIC
        ELSE IF @LoadType = 'I'
        BEGIN
            -- Create temp table for merge output tracking
            DECLARE @MergeOutput TABLE (
                [Action] NVARCHAR(10),
                [RowCount] INT
            );
            
            -- Use MERGE for incremental updates
            -- Assuming the key is: System, GL Account, Entity System Code, Balance/Cost Group
            MERGE [dbo].[Cognos Accounts] AS tgt
            USING (
                SELECT 
                    [Description Cognos accts],
                    [GL Account],
                    [Entity System Code],
                    [Entity Code],
                    [Balance/Cost Group],
                    [Cognos Account],
                    [System],	  
                    [Counterparty Code],
                    [Counterparty Name],
                    @LineageKey AS [Lineage_Key]
                FROM [SCH1SQL1V16].[STAGING_MDS].[dbo].[Cognos Accounts]
                -- Add WHERE clause here if MDS has a modified date column
                -- WHERE ModifiedDate > @LastLoadDate
            ) AS src 
            ON tgt.[System] = src.[System]
                AND tgt.[GL Account] = src.[GL Account]
                AND tgt.[Entity System Code] = src.[Entity System Code]
                AND tgt.[Balance/Cost Group] = src.[Balance/Cost Group]
            
            -- Update existing records if any column has changed
            WHEN MATCHED AND (
                ISNULL(tgt.[Description Cognos accts], '') != ISNULL(src.[Description Cognos accts], '') OR
                ISNULL(tgt.[Entity Code], '') != ISNULL(src.[Entity Code], '') OR
                ISNULL(tgt.[Cognos_Account], '') != ISNULL(src.[Cognos Account], '') OR
                ISNULL(tgt.[Counterparty Code], '') != ISNULL(src.[Counterparty Code], '') OR
                ISNULL(tgt.[Counterparty Name], '') != ISNULL(src.[Counterparty Name], '')
            )
            THEN UPDATE SET
                tgt.[Description Cognos accts] = src.[Description Cognos accts],
                tgt.[Entity Code] = src.[Entity Code],
                tgt.[Cognos_Account] = src.[Cognos Account],
                tgt.[Counterparty Code] = src.[Counterparty Code],
                tgt.[Counterparty Name] = src.[Counterparty Name],
                tgt.[Lineage_Key] = src.[Lineage_Key]
            
            -- Insert new records
            WHEN NOT MATCHED BY TARGET THEN
                INSERT (
                    [Description Cognos accts],
                    [GL Account],
                    [Entity System Code],
                    [Entity Code],
                    [Balance/Cost Group],
                    [Cognos_Account],
                    [System],
                    [Counterparty Code],
                    [Counterparty Name],
                    [Lineage_Key]
                )
                VALUES (
                    src.[Description Cognos accts],
                    src.[GL Account],
                    src.[Entity System Code],
                    src.[Entity Code],
                    src.[Balance/Cost Group],
                    src.[Cognos Account],
                    src.[System],
                    src.[Counterparty Code],
                    src.[Counterparty Name],
                    src.[Lineage_Key]
                )
            
            -- Delete records not in source
            WHEN NOT MATCHED BY SOURCE THEN DELETE
            
            OUTPUT 
                $action AS [Action],
                1 AS [RowCount]
            INTO @MergeOutput;
            
            -- Count the operations
            SELECT 
                @RowsInserted = SUM(CASE WHEN [Action] = 'INSERT' THEN [RowCount] ELSE 0 END),
                @RowsUpdated = SUM(CASE WHEN [Action] = 'UPDATE' THEN [RowCount] ELSE 0 END),
                @RowsDeleted = SUM(CASE WHEN [Action] = 'DELETE' THEN [RowCount] ELSE 0 END)
            FROM @MergeOutput;
            
            SET @RowCount = ISNULL(@RowsInserted, 0) + ISNULL(@RowsUpdated, 0) + ISNULL(@RowsDeleted, 0);
        END
        
        SET @EndTime = SYSDATETIME();
        
        -- Build success message
        SET @OutputMessage = CONCAT(
            'Load completed successfully. ',
            'Rows: ', @RowCount, ' ',
            '(Inserted: ', @RowsInserted, ', ',
            'Updated: ', @RowsUpdated, ', ',
            'Deleted: ', @RowsDeleted, '). ',
            'Duration: ', DATEDIFF(SECOND, @StartTime, @EndTime), ' seconds.'
        );
        
        COMMIT TRANSACTION;
        
        -- Update the lineage table with row counts
        UPDATE [exe].[Lineage]
        SET 
            [Row_Count] = @RowCount,
            [Rows_Inserted] = @RowsInserted,
            [Rows_Updated] = @RowsUpdated,
            [Rows_Deleted] = @RowsDeleted
        WHERE [Lineage_Key] = @LineageKey;
        
        -- Return results for the calling process
        SELECT 
            @RowCount AS [RowCount],
            @RowsInserted AS [RowsInserted],
            @RowsUpdated AS [RowsUpdated],
            @RowsDeleted AS [RowsDeleted],
            @OutputMessage AS [OutputMessage],
            'Success' AS [Status];
        
        RETURN 0;
    END TRY
    BEGIN CATCH
        IF @@TRANCOUNT > 0
            ROLLBACK TRANSACTION;
        
        -- Capture error details
        SET @ErrorNumber = ERROR_NUMBER();
        SET @ErrorSeverity = ERROR_SEVERITY();
        SET @ErrorState = ERROR_STATE();
        SET @OutputMessage = CONCAT(
            'Error ', @ErrorNumber, ': ',
            ERROR_MESSAGE(),
            ' (Line: ', ERROR_LINE(), ')'
        );
        
        -- Update the lineage table with error info
        UPDATE [exe].[Lineage]
        SET 
            [Row_Count] = 0,
            [Rows_Inserted] = 0,
            [Rows_Updated] = 0,
            [Rows_Deleted] = 0
        WHERE [Lineage_Key] = @LineageKey;
        
        -- Return error information
        SELECT 
            0 AS [RowCount],
            0 AS [RowsInserted],
            0 AS [RowsUpdated],
            0 AS [RowsDeleted],
            @OutputMessage AS [OutputMessage],
            'Error' AS [Status],
            @ErrorNumber AS [ErrorNumber],
            @ErrorSeverity AS [ErrorSeverity],
            @ErrorState AS [ErrorState];
        
        -- Re-throw the error
        THROW;
        
        RETURN -1;
    END CATCH
END;
GO
/****** Object:  StoredProcedure [dbo].[Load_MDS_Entity Adjustments]    Script Date: 27-8-2025 13:37:43 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE   PROCEDURE [dbo].[Load_MDS_Entity Adjustments]
    @LineageKey INT,
    @LoadType CHAR(1) = 'F',  -- F=Full, I=Incremental
    @LastLoadDate DATETIME2(7) = NULL
AS
BEGIN
    SET NOCOUNT ON;
    SET XACT_ABORT ON;
    
    -- Variables for tracking results
    DECLARE @RowCount INT = 0;
    DECLARE @RowsInserted INT = 0;
    DECLARE @RowsUpdated INT = 0;
    DECLARE @RowsDeleted INT = 0;
    DECLARE @OutputMessage NVARCHAR(MAX);
    DECLARE @System NVARCHAR(25) = 'MDS';
    DECLARE @TableName NVARCHAR(100) = 'Entity Adjustments';
    
    BEGIN TRY
        
        BEGIN TRANSACTION;
        
        -- Create temp table for capturing merge output
        CREATE TABLE #MergeOutput (
            ActionType NVARCHAR(10)
        );
        
        -- MERGE statement for Entity Adjustments table
        MERGE [dbo].[Entity Adjustments] AS target
        USING (
            SELECT 
                [Entity Description],
                [Entity System Code],
                [Country],
                [System],
                [SB Code],
                [Active],
                [SB Description],
                [Entity Code],
                [Managerial Structure],
                [Managerial Description],
                @LineageKey AS [Lineage_Key]
            FROM [SCH1SQL1V16].[STAGING_MDS].[dbo].[Entity Adjustments]
            -- For incremental loads, you could add a WHERE clause here if source has timestamps
            -- WHERE (@LoadType = 'F' OR ModifiedDate > @LastLoadDate)
        ) AS source 
        ON target.[Entity System Code] = source.[Entity System Code] COLLATE SQL_Latin1_General_CP1_CI_AS
        AND target.[System] = source.[System] COLLATE SQL_Latin1_General_CP1_CI_AS
        
        -- Update existing records if any column has changed
        WHEN MATCHED AND (
            ISNULL(target.[Entity Description], '') != ISNULL(source.[Entity Description] COLLATE SQL_Latin1_General_CP1_CI_AS, '') OR
            ISNULL(target.[Country], '') != ISNULL(source.[Country] COLLATE SQL_Latin1_General_CP1_CI_AS, '') OR
            ISNULL(target.[SB Code], '') != ISNULL(source.[SB Code] COLLATE SQL_Latin1_General_CP1_CI_AS, '') OR
            ISNULL(target.[Active], 0) != ISNULL(source.[Active] COLLATE SQL_Latin1_General_CP1_CI_AS, 0) OR
            ISNULL(target.[SB Description], '') != ISNULL(source.[SB Description] COLLATE SQL_Latin1_General_CP1_CI_AS, '') OR
            ISNULL(target.[Entity Code], '') != ISNULL(source.[Entity Code] COLLATE SQL_Latin1_General_CP1_CI_AS, '') OR
            ISNULL(target.[Managerial Structure], '') != ISNULL(source.[Managerial Structure] COLLATE SQL_Latin1_General_CP1_CI_AS, '') OR
            ISNULL(target.[Managerial Description], '') != ISNULL(source.[Managerial Description] COLLATE SQL_Latin1_General_CP1_CI_AS, '')
        ) THEN UPDATE SET
            [Entity Description] = source.[Entity Description],
            [Country] = source.[Country],
            [SB Code] = source.[SB Code],
            [Active] = source.[Active],
            [SB Description] = source.[SB Description],
            [Entity Code] = source.[Entity Code],
            [Managerial Structure] = source.[Managerial Structure],
            [Managerial Description] = source.[Managerial Description],
            [Lineage_Key] = source.[Lineage_Key]
            
        -- Insert new records
        WHEN NOT MATCHED BY TARGET THEN INSERT (
            [Entity Description],
            [Entity System Code],
            [Country],
            [System],
            [SB Code],
            [Active],
            [SB Description],
            [Entity Code],
            [Managerial Structure],
            [Managerial Description],
            [Lineage_Key]
        )
        VALUES (
            source.[Entity Description],
            source.[Entity System Code],
            source.[Country],
            source.[System],
            source.[SB Code],
            source.[Active],
            source.[SB Description],
            source.[Entity Code],
            source.[Managerial Structure],
            source.[Managerial Description],
            source.[Lineage_Key]
        )
        
        -- Delete records that no longer exist in source
        -- For incremental loads, you might want to skip the DELETE clause
        WHEN NOT MATCHED BY SOURCE 
            AND @LoadType = 'F'  -- Only delete on full loads
        THEN DELETE
        
        -- Output clause to capture what happened
        OUTPUT $action INTO #MergeOutput(ActionType);
        
        -- Get the counts from the merge output
        SELECT 
            @RowsInserted = COUNT(CASE WHEN ActionType = 'INSERT' THEN 1 END),
            @RowsUpdated = COUNT(CASE WHEN ActionType = 'UPDATE' THEN 1 END),
            @RowsDeleted = COUNT(CASE WHEN ActionType = 'DELETE' THEN 1 END)
        FROM #MergeOutput;
        
        SET @RowCount = @RowsInserted + @RowsUpdated + @RowsDeleted;
        
        -- Clean up temp table
        DROP TABLE #MergeOutput;
        
        COMMIT TRANSACTION;
        
        -- Build success message
        SET @OutputMessage = CONCAT(
            'Entity Adjustments load completed. ',
            'Type: ', CASE WHEN @LoadType = 'F' THEN 'Full' ELSE 'Incremental' END,
            ' | From: ', CONVERT(VARCHAR(30), @LastLoadDate, 120),
            ' | Rows affected: ', @RowCount,
            ' (Inserted: ', @RowsInserted,
            ', Updated: ', @RowsUpdated,
            ', Deleted: ', @RowsDeleted, ')'
        );
        
        -- Return results for lineage tracking
        -- This is what the framework expects
        SELECT @RowCount AS [RowCount], @OutputMessage AS OutputMessage;
        
        PRINT @OutputMessage;
        RETURN 0;
        
    END TRY
    BEGIN CATCH
        IF @@TRANCOUNT > 0
            ROLLBACK TRANSACTION;
        
        -- Clean up temp table if it exists
        IF OBJECT_ID('tempdb..#MergeOutput') IS NOT NULL
            DROP TABLE #MergeOutput;
        
        -- Capture error details
        DECLARE @ErrorMessage NVARCHAR(4000) = ERROR_MESSAGE();
        DECLARE @ErrorNumber INT = ERROR_NUMBER();
        DECLARE @ErrorSeverity INT = ERROR_SEVERITY();
        DECLARE @ErrorState INT = ERROR_STATE();
        DECLARE @ErrorLine INT = ERROR_LINE();
        
        -- Build error message
        SET @OutputMessage = CONCAT(
            'Error ', @ErrorNumber,
            ' at line ', @ErrorLine, ': ', @ErrorMessage
        );
        
        -- Return error for lineage tracking
        SET @RowCount = 0;
        SELECT @RowCount AS [RowCount], @OutputMessage AS OutputMessage;
        
        -- Log error for debugging
        PRINT @OutputMessage;
        
        -- Don't re-throw since we're returning the error info
        RETURN -1;
    END CATCH
END;
GO
/****** Object:  StoredProcedure [dbo].[Load_MDS_UploadFile]    Script Date: 27-8-2025 13:37:43 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE   PROCEDURE [dbo].[Load_MDS_UploadFile]
    @LineageKey INT,
    @LoadType CHAR(1) = 'F',  -- F=Full, I=Incremental
    @LastLoadDate DATETIME2(7) = NULL
AS
BEGIN
    SET NOCOUNT ON;
    SET XACT_ABORT ON;
    
    -- Variables for tracking results
    DECLARE @RowCount INT = 0;
    DECLARE @RowsInserted INT = 0;
    DECLARE @RowsUpdated INT = 0;
    DECLARE @RowsDeleted INT = 0;
    DECLARE @OutputMessage NVARCHAR(MAX);
    DECLARE @System NVARCHAR(25) = 'MDS';
    DECLARE @TableName NVARCHAR(100) = 'MDS_UploadFile';
    DECLARE @MaxPeriod NVARCHAR(10);
    
    BEGIN TRY
        
        BEGIN TRANSACTION;
        
        -- Truncate destination table (full refresh approach)
        TRUNCATE TABLE [dbo].[UploadFile];
        
        -- Get the maximum period from staging
        SELECT @MaxPeriod = MAX(Period) 
        FROM [SCH1SQL1V16].[STAGING_MDS].[dbo].[UploadFile];
        
        -- Insert data from staging
        INSERT INTO [dbo].[UploadFile] (
            [LKQ BNF (SB0100)],
            [Key],
            [Entity System Code],
            [System],
            [Entity Code],
            [Entity],
            [Year],
            [per],
            [Period],
            [GL account],
            [Description],
            [Balance/Cost],
            [Description Balance/Cost group],
            [Cost Center],
            [Description Costcenter],
            [BS / IS],
            [Concatenate],
            [Total Balance],
            [Adjustment],
            [Upload Balance],
            [Cognos account],
            [Description Cognos accts],
            [Lineage_Key],
            GL_Table_Key,
            Entity_Table_Key
        )
        SELECT 
            U.[LKQ BNF (SB0100)],
            U.[Key],
            U.[Entity System Code],
            U.[System],
            U.[Entity Code],
            U.[Entity],
            U.[Year],
            U.[per],
            U.[Period],
            U.[GL account],
            U.[Description],
            U.[Balance/Cost],
            U.[Description Balance/Cost group],
            U.[Cost Center],
            U.[Description Costcenter],
            U.[BS / IS],
            U.[Concatenate],
            U.[Total Balance],
            U.[Adjustment],
            U.[Upload Balance],
            U.[Cognos account],
            U.[Description Cognos accts],
            @LineageKey,
            GL.GL_Table_Key,
            E.Entity_Table_Key
        FROM [SCH1SQL1V16].[STAGING_MDS].[dbo].[UploadFile] U
        LEFT JOIN [dbo].[GL_Table] GL
            ON GL.System = U.System COLLATE Czech_CI_AS
            AND CAST(TRY_CAST(GL.[GL Account] AS INT) AS VARCHAR) = U.[GL account] COLLATE Czech_CI_AS 
            AND (
                -- AXBE logic
                (GL.System = 'AXBE' AND 
                    (
                        GL.[Entity System Code] = U.[Entity System Code] COLLATE Czech_CI_AS
                        OR (GL.[Entity System Code] = 'vir' AND U.[Entity System Code] COLLATE Czech_CI_AS <> '700')
                    )
                )
                OR
                -- AXNL logic
                (GL.System = 'AXNL' AND GL.[Entity System Code] = 'vir')
                OR
                -- FINACC logic
                (GL.System = 'FINACC'
                    AND GL.[Entity System Code] = U.[Entity System Code] COLLATE Czech_CI_AS
                    AND GL.BOEKJR = U.Year COLLATE Czech_CI_AS
                )
            )
        LEFT JOIN [dbo].[Entity] E
            ON E.System = U.System COLLATE Czech_CI_AS
            AND E.[Entity System Code] = U.[Entity System Code] COLLATE Czech_CI_AS
        WHERE (@MaxPeriod IS NULL OR @MaxPeriod = '' OR U.[Period] = @MaxPeriod)
            -- For incremental loads, add date filter if source has timestamps
            -- AND (@LoadType = 'F' OR U.ModifiedDate > @LastLoadDate)
        ;
        
        SET @RowsInserted = @@ROWCOUNT;
        SET @RowCount = @RowsInserted;
        
        COMMIT TRANSACTION;
        
        -- Build success message
        SET @OutputMessage = CONCAT(
            'MDS UploadFile load completed. ',
            'Type: ', CASE WHEN @LoadType = 'F' THEN 'Full' ELSE 'Incremental' END,
            ' | Period: ', ISNULL(@MaxPeriod, 'All'),
            ' | From: ', CONVERT(VARCHAR(30), @LastLoadDate, 120),
            ' | Rows inserted: ', @RowsInserted
        );
        
        -- Return results for lineage tracking
        -- This is what the framework expects
        SELECT @RowCount AS [RowCount], @OutputMessage AS OutputMessage;
        
        PRINT @OutputMessage;
        RETURN 0;
        
    END TRY
    BEGIN CATCH
        IF @@TRANCOUNT > 0
            ROLLBACK TRANSACTION;
        
        -- Capture error details
        DECLARE @ErrorMessage NVARCHAR(4000) = ERROR_MESSAGE();
        DECLARE @ErrorNumber INT = ERROR_NUMBER();
        DECLARE @ErrorSeverity INT = ERROR_SEVERITY();
        DECLARE @ErrorState INT = ERROR_STATE();
        DECLARE @ErrorLine INT = ERROR_LINE();
        
        -- Build error message
        SET @OutputMessage = CONCAT(
            'Error ', @ErrorNumber,
            ' at line ', @ErrorLine, ': ', @ErrorMessage
        );
        
        -- Return error for lineage tracking
        SET @RowCount = 0;
        SELECT @RowCount AS [RowCount], @OutputMessage AS OutputMessage;
        
        -- Log error for debugging
        PRINT @OutputMessage;
        
        -- Don't re-throw since we're returning the error info
        RETURN -1;
    END CATCH
END;
GO
/****** Object:  StoredProcedure [dbo].[Load_Sites]    Script Date: 27-8-2025 13:37:43 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE   PROCEDURE [dbo].[Load_Sites]
    @LineageKey INT,
    @LoadType CHAR(1) = 'F',  -- F=Full, I=Incremental
    @LastLoadDate DATETIME2(7) = NULL
AS
BEGIN
    SET NOCOUNT ON;
    SET XACT_ABORT ON;
    
    -- Variables for tracking results
    DECLARE @RowCount INT = 0;
    DECLARE @RowsInserted INT = 0;
    DECLARE @RowsUpdated INT = 0;
    DECLARE @RowsDeleted INT = 0;
    DECLARE @OutputMessage NVARCHAR(MAX);
    DECLARE @System NVARCHAR(25) = 'MULTI';  -- Multiple systems
    DECLARE @TableName NVARCHAR(100) = 'Sites';
    
    BEGIN TRY
        -- If LastLoadDate is not provided, set a default
        IF @LastLoadDate IS NULL
        BEGIN
            IF @LoadType = 'I'
                SET @LastLoadDate = DATEADD(DAY, -7, GETDATE());  -- Default to last 7 days for incremental
            ELSE
                SET @LastLoadDate = '1900-01-01';  -- Default for full load
        END
        
        BEGIN TRANSACTION;
        
        -- Truncate destination table (full refresh approach)
        TRUNCATE TABLE [dbo].[Sites];
        
        -- Insert data from AXNL staging
        INSERT INTO [dbo].[Sites] (
            [System],
            [Site_Name],
            [Site_Nummer],
            [Dimension],
            [Region],
            [Lineage_Key]
        )
        SELECT 
            'AXNL' as [System],
            [DESCRIPTION] as [Site_Name],
            [NUM] as [Site_Nummer],
            [DIMENSIONCODE] as [Dimension],
            [COMPANYGROUP] as [Region],
            @LineageKey AS [Lineage_Key]
        FROM [SCH1SQL1V16].[STAGING_AXNL].[dbo].[DIMENSIONS]
        -- For incremental loads, add WHERE clause if source has timestamps
        -- WHERE (@LoadType = 'F' OR ModifiedDate > @LastLoadDate)
        
        UNION
        
        SELECT 
            'AXBE' as [System],
            [DESCRIPTION] as [Site_Name],
            [NUM] as [Site_Nummer],
            [DIMENSIONCODE] as [Dimension],
            [COMPANYGROUP] as [Region],
            @LineageKey AS [Lineage_Key]
        FROM [SCH1SQL1V16].[STAGING_AXBE].[dbo].[DIMENSIONS]
        -- For incremental loads, add WHERE clause if source has timestamps
        -- WHERE (@LoadType = 'F' OR ModifiedDate > @LastLoadDate)
        ;
        
        SET @RowsInserted = @@ROWCOUNT;
        SET @RowCount = @RowsInserted;
        
        COMMIT TRANSACTION;
        
        -- Build success message
        SET @OutputMessage = CONCAT(
            'Sites load completed. ',
            'Type: ', CASE WHEN @LoadType = 'F' THEN 'Full' ELSE 'Incremental' END,
            ' | From: ', CONVERT(VARCHAR(30), @LastLoadDate, 120),
            ' | Rows inserted: ', @RowsInserted,
            ' (from AXNL and AXBE systems)'
        );
        
        -- Return results for lineage tracking
        -- This is what the framework expects
        SELECT @RowCount AS [RowCount], @OutputMessage AS OutputMessage;
        
        PRINT @OutputMessage;
        RETURN 0;
        
    END TRY
    BEGIN CATCH
        IF @@TRANCOUNT > 0
            ROLLBACK TRANSACTION;
        
        -- Capture error details
        DECLARE @ErrorMessage NVARCHAR(4000) = ERROR_MESSAGE();
        DECLARE @ErrorNumber INT = ERROR_NUMBER();
        DECLARE @ErrorSeverity INT = ERROR_SEVERITY();
        DECLARE @ErrorState INT = ERROR_STATE();
        DECLARE @ErrorLine INT = ERROR_LINE();
        
        -- Build error message
        SET @OutputMessage = CONCAT(
            'Error ', @ErrorNumber,
            ' at line ', @ErrorLine, ': ', @ErrorMessage
        );
        
        -- Return error for lineage tracking
        SET @RowCount = 0;
        SELECT @RowCount AS [RowCount], @OutputMessage AS OutputMessage;
        
        -- Log error for debugging
        PRINT @OutputMessage;
        
        -- Don't re-throw since we're returning the error info
        RETURN -1;
    END CATCH
END;
GO
/****** Object:  StoredProcedure [dbo].[Load_Table_Template]    Script Date: 27-8-2025 13:37:43 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

-- =============================================
-- COMPONENT 7: Table Template
-- =============================================
CREATE   PROCEDURE [dbo].[Load_Table_Template]
    @LineageKey INT,
    @LoadType CHAR(1) = 'F',  -- F=Full, I=Incremental
    @LastLoadDate DATETIME2(7) = NULL
AS
BEGIN
    SET NOCOUNT ON;
    SET XACT_ABORT ON;
    
    -- Declare variables
    DECLARE @RowCount BIGINT = 0;
    DECLARE @RowsInserted BIGINT = 0;
    DECLARE @RowsUpdated BIGINT = 0;
    DECLARE @RowsDeleted BIGINT = 0;
    DECLARE @OutputMessage NVARCHAR(MAX);
    DECLARE @ErrorNumber INT;
    DECLARE @ErrorSeverity INT;
    DECLARE @ErrorState INT;
    DECLARE @StartTime DATETIME2(7) = SYSDATETIME();
    DECLARE @EndTime DATETIME2(7);
    
    BEGIN TRY
        BEGIN TRANSACTION;
        
        -- Validate LineageKey
        IF NOT EXISTS (SELECT 1 FROM [exe].[Lineage] WHERE [Lineage_Key] = @LineageKey)
        BEGIN
            RAISERROR('Invalid LineageKey: %d', 16, 1, @LineageKey);
            RETURN -1;
        END
        
        -- For incremental loads, get last load date if not provided
        IF @LoadType = 'I' AND @LastLoadDate IS NULL
        BEGIN
            SELECT @LastLoadDate = [Last_Loaded_Date]
            FROM [exe].[Lineage]
            WHERE [Lineage_Key] = @LineageKey;
        END
        
        -- FULL LOAD LOGIC
        IF @LoadType = 'F'
        BEGIN
            -- Truncate target table
            TRUNCATE TABLE [Target_Schema].[Target_Table];
            
            -- Insert all data
            INSERT INTO [Target_Schema].[Target_Table] (
                [Column1],
                [Column2],
                [Column3],
                -- ... other columns
                [LineageKey]
            )
            SELECT 
                src.[Column1],
                src.[Column2],
                src.[Column3],
                -- ... other columns
                @LineageKey
            FROM [Source_Schema].[Source_Table] AS src
            LEFT JOIN [Other_Schema].[Other_Table] AS oth
                ON src.[JoinKey] = oth.[JoinKey]
            WHERE 1=1  -- Add any filtering conditions
            OPTION (RECOMPILE);  -- Use for parameter sniffing issues
            
            SET @RowsInserted = @@ROWCOUNT;
            SET @RowCount = @RowsInserted;
        END
        
        -- INCREMENTAL LOAD LOGIC
        ELSE IF @LoadType = 'I'
        BEGIN
            -- Create temp table for merge output
            DECLARE @MergeOutput TABLE (
                [Action] NVARCHAR(10),
                [RowCount] INT
            );
            
            -- Use MERGE for incremental updates
            MERGE [Target_Schema].[Target_Table] AS tgt
            USING (
                SELECT 
                    src.[Key_Column],
                    src.[Column1],
                    src.[Column2],
                    src.[Column3],
                    -- ... other columns
                    @LineageKey AS [LineageKey]
                FROM [Source_Schema].[Source_Table] AS src
                WHERE src.[Modified_Date] > @LastLoadDate  -- Incremental filter
            ) AS src ON tgt.[Key_Column] = src.[Key_Column]
            
            -- Update existing records
            WHEN MATCHED AND (
                tgt.[Column1] != src.[Column1] OR
                tgt.[Column2] != src.[Column2] OR
                tgt.[Column3] != src.[Column3]
                -- Check other columns for changes
            )
            THEN UPDATE SET
                tgt.[Column1] = src.[Column1],
                tgt.[Column2] = src.[Column2],
                tgt.[Column3] = src.[Column3],
                -- ... update other columns
                tgt.[LineageKey] = src.[LineageKey]
            
            -- Insert new records
            WHEN NOT MATCHED BY TARGET THEN
                INSERT (
                    [Key_Column],
                    [Column1],
                    [Column2],
                    [Column3],
                    -- ... other columns
                    [LineageKey]
                )
                VALUES (
                    src.[Key_Column],
                    src.[Column1],
                    src.[Column2],
                    src.[Column3],
                    -- ... other values
                    src.[LineageKey]
                )
            
            -- Optional: Delete records not in source
            -- WHEN NOT MATCHED BY SOURCE THEN DELETE
            
            OUTPUT 
                $action AS [Action],
                1 AS [RowCount]
            INTO @MergeOutput;
            
            -- Count the operations
            SELECT 
                @RowsInserted = SUM(CASE WHEN [Action] = 'INSERT' THEN [RowCount] ELSE 0 END),
                @RowsUpdated = SUM(CASE WHEN [Action] = 'UPDATE' THEN [RowCount] ELSE 0 END),
                @RowsDeleted = SUM(CASE WHEN [Action] = 'DELETE' THEN [RowCount] ELSE 0 END)
            FROM @MergeOutput;
            
            SET @RowCount = @RowsInserted + @RowsUpdated + @RowsDeleted;
        END
        
        SET @EndTime = SYSDATETIME();
        
        -- Build success message
        SET @OutputMessage = CONCAT(
            'Load completed successfully. ',
            'Rows: ', @RowCount, ' ',
            '(Inserted: ', @RowsInserted, ', ',
            'Updated: ', @RowsUpdated, ', ',
            'Deleted: ', @RowsDeleted, '). ',
            'Duration: ', DATEDIFF(SECOND, @StartTime, @EndTime), ' seconds.'
        );
        
        COMMIT TRANSACTION;
        
        -- Return results for the calling process
        SELECT 
            @RowCount AS [RowCount],
            @RowsInserted AS [RowsInserted],
            @RowsUpdated AS [RowsUpdated],
            @RowsDeleted AS [RowsDeleted],
            @OutputMessage AS [OutputMessage],
            'Success' AS [Status];
        
        RETURN 0;
    END TRY
    BEGIN CATCH
        IF @@TRANCOUNT > 0
            ROLLBACK TRANSACTION;
        
        -- Capture error details
        SET @ErrorNumber = ERROR_NUMBER();
        SET @ErrorSeverity = ERROR_SEVERITY();
        SET @ErrorState = ERROR_STATE();
        SET @OutputMessage = CONCAT(
            'Error ', @ErrorNumber, ': ',
            ERROR_MESSAGE(),
            ' (Line: ', ERROR_LINE(), ')'
        );
        
        -- Return error information
        SELECT 
            0 AS [RowCount],
            0 AS [RowsInserted],
            0 AS [RowsUpdated],
            0 AS [RowsDeleted],
            @OutputMessage AS [OutputMessage],
            'Error' AS [Status],
            @ErrorNumber AS [ErrorNumber],
            @ErrorSeverity AS [ErrorSeverity],
            @ErrorState AS [ErrorState];
        
        -- Re-throw the error
        THROW;
        
        RETURN -1;
    END CATCH
END;

GO
/****** Object:  StoredProcedure [exe].[00_PreCheck_Tables]    Script Date: 27-8-2025 13:37:43 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE   PROCEDURE [exe].[00_PreCheck_Tables]
    @System NVARCHAR(25) = NULL,
    @RunGroup NVARCHAR(250) = NULL,
    @ShowDetails BIT = 1,
    @AutoFix BIT = 0,
    @OverrideLoadType CHAR(1) = NULL OUTPUT  -- Pass through for display
AS
BEGIN
    SET NOCOUNT ON;
    
    DECLARE @HasIssues BIT = 0;
    DECLARE @StuckCount INT = 0;
    DECLARE @ErrorCount INT = 0;
    DECLARE @TotalTables INT = 0;
    DECLARE @AvailableTables INT = 0;
    DECLARE @BlockedCount INT = 0;
    
    PRINT '========================================';
    PRINT 'ETL Pre-Check Report';
    PRINT '========================================';
    PRINT CONCAT('Time: ', CONVERT(NVARCHAR(30), GETDATE(), 120));
    PRINT '';
    
    -- EXECUTION PARAMETERS
    PRINT 'EXECUTION PARAMETERS:';
    PRINT '--------------------';
    PRINT CONCAT('System: ', ISNULL(@System, 'ALL'));
    PRINT CONCAT('RunGroup: ', ISNULL(@RunGroup, 'ALL'));
    IF @OverrideLoadType IS NOT NULL
        PRINT CONCAT('Load Type Override: ', @OverrideLoadType, ' (Will override configured load types)');
    PRINT '';
    
    -- TABLE AVAILABILITY
    SELECT @TotalTables = COUNT(*)
    FROM [exe].[Table_List]
    WHERE (@System IS NULL OR [System] = @System)
        AND [Is_Active] = 1
        AND (@RunGroup IS NULL OR [Run_Group] = @RunGroup);
    
    SELECT @AvailableTables = COUNT(*)
    FROM [exe].[Table_List]
    WHERE (@System IS NULL OR [System] = @System)
        AND [Is_Active] = 1
        AND (@RunGroup IS NULL OR [Run_Group] = @RunGroup)
        AND ([Load_Status] IS NULL OR [Load_Status] NOT IN ('P', 'R'));
    
    SET @BlockedCount = @TotalTables - @AvailableTables;
    
    PRINT 'TABLE AVAILABILITY:';
    PRINT '-------------------';
    PRINT CONCAT('Total eligible tables: ', @TotalTables);
    PRINT CONCAT('Available to process: ', @AvailableTables);
    IF @BlockedCount > 0
        PRINT CONCAT('Blocked by status: ', @BlockedCount, ' (P=Processing, R=Running)');
    PRINT '';
    
    -- TABLE STATUS SUMMARY
    PRINT 'STATUS BREAKDOWN:';
    PRINT '-----------------';
    
    SELECT 
        ISNULL([Load_Status], 'NULL') as Status,
        COUNT(*) as Count,
        CASE 
            WHEN [Load_Status] = 'S' THEN 'Success (last run)'
            WHEN [Load_Status] = 'E' THEN 'Error (needs retry)'
            WHEN [Load_Status] = 'P' THEN 'In Progress (stuck?)'
            WHEN [Load_Status] = 'W' THEN 'Warning'
            WHEN [Load_Status] = 'R' THEN 'Running'
            ELSE 'Ready to run'
        END as Description
    FROM [exe].[Table_List]
    WHERE (@System IS NULL OR [System] = @System)
        AND [Is_Active] = 1
        AND (@RunGroup IS NULL OR [Run_Group] = @RunGroup)
    GROUP BY [Load_Status]
    ORDER BY 
        CASE [Load_Status]
            WHEN 'P' THEN 1  -- Show problems first
            WHEN 'R' THEN 2
            WHEN 'E' THEN 3
            WHEN 'W' THEN 4
            ELSE 5
        END,
        [Load_Status];
    
    -- Check for stuck in-progress tables
    SELECT @StuckCount = COUNT(*)
    FROM [exe].[Table_List] tl
    WHERE (@System IS NULL OR tl.[System] = @System)
        AND tl.[Is_Active] = 1
        AND (@RunGroup IS NULL OR tl.[Run_Group] = @RunGroup)
        AND tl.[Load_Status] = 'P';
    
    IF @StuckCount > 0
    BEGIN
        SET @HasIssues = 1;
        PRINT '';
        PRINT CONCAT(' WARNING: ', @StuckCount, ' table(s) stuck in progress!');
        PRINT '================================================';
        
        -- Show stuck tables with details
        SELECT 
            tl.[System],
            tl.[Table_Name],
            tl.[Execution_Order],
            tl.[Last_Loaded_Date],
            l.[Lineage_Key],
            l.[Start_Load] as Stuck_Since,
            DATEDIFF(MINUTE, l.[Start_Load], GETDATE()) as Minutes_Stuck,
            LEFT(l.[Output_Message], 100) as Last_Message
        FROM [exe].[Table_List] tl
        LEFT JOIN (
            SELECT 
                [System], 
                [Table_Name], 
                [Lineage_Key],
                [Start_Load], 
                [Output_Message],
                ROW_NUMBER() OVER (PARTITION BY [System], [Table_Name] ORDER BY [Start_Load] DESC) as rn
            FROM [exe].[Lineage]
            WHERE [Load_Status] = 'P'
        ) l ON tl.[System] = l.[System] 
            AND tl.[Table_Name] = l.[Table_Name] 
            AND l.rn = 1
        WHERE (@System IS NULL OR tl.[System] = @System)
            AND tl.[Is_Active] = 1
            AND (@RunGroup IS NULL OR tl.[Run_Group] = @RunGroup)
            AND tl.[Load_Status] = 'P'
        ORDER BY l.[Start_Load];
        
        IF @AutoFix = 1
        BEGIN
            PRINT '';
            PRINT ' AUTO-FIXING stuck tables...';
            
            -- Fix stuck lineage entries
            UPDATE l
            SET [Load_Status] = 'E',
                [Finish_Load] = GETDATE(),
                [Output_Message] = CONCAT('Auto-terminated after ', 
                    DATEDIFF(MINUTE, [Start_Load], GETDATE()), ' minutes')
            FROM [exe].[Lineage] l
            INNER JOIN [exe].[Table_List] tl 
                ON l.[System] = tl.[System] 
                AND l.[Table_Name] = tl.[Table_Name]
            WHERE l.[Load_Status] = 'P'
                AND (@System IS NULL OR tl.[System] = @System)
                AND tl.[Is_Active] = 1
                AND (@RunGroup IS NULL OR tl.[Run_Group] = @RunGroup);
            
            PRINT CONCAT('  Fixed ', @@ROWCOUNT, ' lineage entries');
            
            -- Reset table status
            UPDATE [exe].[Table_List]
            SET [Load_Status] = NULL,
                [Retry_Count] = 0,
                [Output_Message] = 'Reset by PreCheck AutoFix',
                [Modified_Date] = GETDATE(),
                [Modified_By] = SUSER_SNAME()
            WHERE (@System IS NULL OR [System] = @System)
                AND [Is_Active] = 1
                AND (@RunGroup IS NULL OR [Run_Group] = @RunGroup)
                AND [Load_Status] = 'P';
            
            PRINT CONCAT('  Reset ', @@ROWCOUNT, ' table(s)');
            PRINT ' Auto-fix completed';
        END
        ELSE
        BEGIN
            PRINT '';
            PRINT ' To fix these tables:';
            PRINT '   Option 1: Add @AutoFixStuck = 1 to auto-fix';
            PRINT '   Option 2: Add @ForceStart = 1 to ignore';
        END
    END
    
    -- Check for tables with errors
    SELECT @ErrorCount = COUNT(*)
    FROM [exe].[Table_List]
    WHERE (@System IS NULL OR [System] = @System)
        AND [Is_Active] = 1
        AND (@RunGroup IS NULL OR [Run_Group] = @RunGroup)
        AND [Load_Status] = 'E';
    
    IF @ErrorCount > 0 AND @ShowDetails = 1
    BEGIN
        PRINT '';
        PRINT CONCAT(' TABLES WITH ERRORS (', @ErrorCount, '):');
        PRINT '--------------------------------';
        
        SELECT 
            [System],
            [Table_Name],
            [Retry_Count] as Retries,
            [Max_Retries] as MaxRetry,
            [Last_Loaded_Date],
            LEFT([Output_Message], 80) as Error_Message
        FROM [exe].[Table_List]
        WHERE (@System IS NULL OR [System] = @System)
            AND [Is_Active] = 1
            AND (@RunGroup IS NULL OR [Run_Group] = @RunGroup)
            AND [Load_Status] = 'E'
        ORDER BY [System], [Table_Name];
    END
    
    -- Check dependencies
    IF @ShowDetails = 1
    BEGIN
        DECLARE @DepIssueCount INT;
        
        ;WITH DependencyCheck AS (
            SELECT 
                t1.[System],
                t1.[Table_Name],
                t1.[Dependencies],
                dep.value as DependencyTable,
                t2.[Load_Status] as DepStatus,
                CASE 
                    WHEN t2.[Table_Name] IS NULL THEN 'NOT FOUND'
                    WHEN t2.[Load_Status] = 'S' THEN 'OK'
                    WHEN t2.[Load_Status] = 'P' THEN 'IN PROGRESS'
                    WHEN t2.[Load_Status] = 'E' THEN 'ERROR'
                    ELSE 'NOT RUN'
                END as DepState
            FROM [exe].[Table_List] t1
            CROSS APPLY STRING_SPLIT(t1.[Dependencies], ',') dep
            LEFT JOIN [exe].[Table_List] t2 
                ON LTRIM(RTRIM(dep.value)) = t2.[Table_Name]
                AND t1.[System] = t2.[System]
            WHERE (@System IS NULL OR t1.[System] = @System)
                AND t1.[Is_Active] = 1
                AND (@RunGroup IS NULL OR t1.[Run_Group] = @RunGroup)
                AND t1.[Dependencies] IS NOT NULL
        )
        SELECT @DepIssueCount = COUNT(DISTINCT [Table_Name])
        FROM DependencyCheck
        WHERE DepState != 'OK';
        
        IF @DepIssueCount > 0
        BEGIN
            PRINT '';
            PRINT CONCAT(' DEPENDENCY ISSUES (', @DepIssueCount, ' tables):');
            PRINT '------------------------------------';
            
            SELECT 
                [System],
                [Table_Name],
                STRING_AGG(CONCAT(DependencyTable, '(', DepState, ')'), ', ') as DependencyStatus
            FROM DependencyCheck
            WHERE DepState != 'OK'
            GROUP BY [System], [Table_Name]
            ORDER BY [System], [Table_Name];
        END
    END
    
    -- FINAL SUMMARY
    PRINT '';
    PRINT '========================================';
    IF @HasIssues = 0
    BEGIN
        PRINT ' RESULT: All checks passed - ready to run!';
    END
    ELSE
    BEGIN
        IF @AutoFix = 1 AND @StuckCount > 0
            PRINT ' RESULT: Issues found and fixed - ready to run!';
        ELSE
            PRINT ' RESULT: Issues found - review above';
    END
    PRINT '========================================';
    
    RETURN @HasIssues;
END;
GO
/****** Object:  StoredProcedure [exe].[01_Get_Table_Config]    Script Date: 27-8-2025 13:37:43 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

-- =============================================
-- 1. CONFIGURATION PROCEDURES
-- =============================================

-- Get table configuration
CREATE   PROCEDURE [exe].[01_Get_Table_Config]
    @TableName NVARCHAR(100),
    @System NVARCHAR(25),
    @SchemaName NVARCHAR(128) OUTPUT,
    @StoredProcedureName NVARCHAR(200) OUTPUT,
    @IsActive BIT OUTPUT,
    @LoadType CHAR(1) OUTPUT,
    @ExecutionOrder INT OUTPUT,
    @RunGroup NVARCHAR(50) OUTPUT,
    @Dependencies NVARCHAR(500) OUTPUT,
    @MaxRetries INT OUTPUT,
    @RetryCount INT OUTPUT,
    @TimeoutSeconds INT OUTPUT,
    @DefaultLoadDays INT OUTPUT,
    @DefaultLoadDate DATETIME2(7) OUTPUT,
    @UseFullHistory BIT OUTPUT,
    @DefaultLoadYears INT OUTPUT,
    @Exists BIT OUTPUT
AS
BEGIN
    SET NOCOUNT ON;
    
    SELECT 
        @SchemaName = [Schema_Name],
        @StoredProcedureName = [Stored_Procedure_Name],
        @IsActive = [Is_Active],
        @LoadType = [Load_Type],
        @ExecutionOrder = [Execution_Order],
        @RunGroup = [Run_Group],
        @Dependencies = [Dependencies],
        @MaxRetries = [Max_Retries],
        @RetryCount = [Retry_Count],
        @TimeoutSeconds = [Timeout_Seconds],
        @DefaultLoadDays = [Default_Load_Days],
        @DefaultLoadDate = [Default_Load_Date],
        @UseFullHistory = [Use_Full_History],
        @DefaultLoadYears = [Default_Load_Years], -- Renamed from Years_Back
        @Exists = 1
    FROM [exe].[Table_List]
    WHERE [Table_Name] = @TableName 
    AND [System] = @System;
    
    IF @@ROWCOUNT = 0
        SET @Exists = 0;
    
    RETURN 0;
END;
GO
/****** Object:  StoredProcedure [exe].[02_Validate_Table]    Script Date: 27-8-2025 13:37:43 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

-- Validate table configuration
CREATE   PROCEDURE [exe].[02_Validate_Table]
    @TableName NVARCHAR(100),
    @System NVARCHAR(25),
    @LoadType CHAR(1) = NULL,
    @IsValid BIT OUTPUT,
    @ValidationMessage NVARCHAR(500) OUTPUT
AS
BEGIN
    SET NOCOUNT ON;
    
    DECLARE @IsActive BIT;
    DECLARE @RetryCount INT;
    DECLARE @MaxRetries INT;
    DECLARE @ConfiguredLoadType CHAR(1);
    
    SET @IsValid = 1;
    SET @ValidationMessage = 'Valid';
    
    -- Check if table exists
    IF NOT EXISTS (SELECT 1 FROM [exe].[Table_List] 
                   WHERE [Table_Name] = @TableName AND [System] = @System)
    BEGIN
        SET @IsValid = 0;
        SET @ValidationMessage = CONCAT('Table ', @TableName, ' for system ', @System, ' not found in Table_List');
        RETURN 0;
    END
    
    -- Get table properties
    SELECT 
        @IsActive = [Is_Active],
        @RetryCount = [Retry_Count],
        @MaxRetries = [Max_Retries],
        @ConfiguredLoadType = [Load_Type]
    FROM [exe].[Table_List]
    WHERE [Table_Name] = @TableName AND [System] = @System;
    
    -- Check if active
    IF @IsActive = 0
    BEGIN
        SET @IsValid = 0;
        SET @ValidationMessage = CONCAT('Table ', @TableName, ' is inactive');
        RETURN 0;
    END
    
    -- Check retry limit
    IF @RetryCount >= @MaxRetries
    BEGIN
        SET @IsValid = 0;
        SET @ValidationMessage = CONCAT('Table ', @TableName, ' has exceeded maximum retries (', @MaxRetries, ')');
        RETURN 0;
    END
    
    -- Validate load type if provided
    IF @LoadType IS NOT NULL AND @LoadType NOT IN ('F', 'I')
    BEGIN
        SET @IsValid = 0;
        SET @ValidationMessage = 'Invalid LoadType. Must be F (Full) or I (Incremental)';
        RETURN 0;
    END
    
    RETURN 0;
END;
GO
/****** Object:  StoredProcedure [exe].[03_Calculate_Load_Date]    Script Date: 27-8-2025 13:37:43 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE   PROCEDURE [exe].[03_Calculate_Load_Date]
    @TableName NVARCHAR(100),
    @System NVARCHAR(25),
    @LoadType CHAR(1),
    @OverrideFullLoad BIT = 0,
    @LastLoadDate DATETIME2(7) OUTPUT,
    @LoadDateSource NVARCHAR(50) OUTPUT
AS
BEGIN
    SET NOCOUNT ON;
    
    DECLARE @DefaultLoadDays INT;
    DECLARE @DefaultLoadDate DATETIME2(7);
    DECLARE @UseFullHistory BIT;
    DECLARE @DefaultLoadYears INT;
    
    -- Get configuration
    SELECT 
        @DefaultLoadDays = [Default_Load_Days],
        @DefaultLoadDate = [Default_Load_Date],
        @UseFullHistory = [Use_Full_History],
        @DefaultLoadYears = [Default_Load_Years]
    FROM [exe].[Table_List]
    WHERE [Table_Name] = @TableName AND [System] = @System;
    
    -- FULL LOAD Logic
    IF @LoadType = 'F' OR @OverrideFullLoad = 1
    BEGIN
        -- Priority 1: Default_Load_Date
        IF @DefaultLoadDate IS NOT NULL
        BEGIN
            SET @LastLoadDate = @DefaultLoadDate;
            SET @LoadDateSource = 'Default_Load_Date (Full)';
        END
        -- Priority 2: Default_Load_Years
        ELSE IF @DefaultLoadYears IS NOT NULL
        BEGIN
            SET @LastLoadDate = DATEADD(YEAR, -@DefaultLoadYears, SYSDATETIME());
            SET @LoadDateSource = CONCAT('Full Load Limited to ', @DefaultLoadYears, ' years');
        END
        -- Priority 3: Default_Load_Days
        ELSE IF @DefaultLoadDays IS NOT NULL
        BEGIN
            SET @LastLoadDate = DATEADD(DAY, -@DefaultLoadDays, SYSDATETIME());
            SET @LoadDateSource = CONCAT('Full Load Limited to ', @DefaultLoadDays, ' days');
        END
        -- Priority 4: Default to full history
        ELSE
        BEGIN
            SET @LastLoadDate = '1900-01-01';
            SET @LoadDateSource = CASE 
                WHEN @UseFullHistory = 1 THEN 'Use_Full_History (Full Load)'
                WHEN @OverrideFullLoad = 1 THEN 'Full Load Override (All History)'
                ELSE 'Full Load Default (All History)'
            END;
        END
        RETURN 0;
    END
    
    -- INCREMENTAL LOAD Logic
    SELECT @LastLoadDate = MAX([Finish_Load]) 
    FROM [exe].[Lineage] 
    WHERE [Table_Name] = @TableName 
    AND [System] = @System 
    AND [Load_Status] = 'S';
    
    -- Priority 1: Last successful load
    IF @LastLoadDate IS NOT NULL
    BEGIN
        SET @LoadDateSource = 'Last successful load';
    END
    -- Priority 2: Default_Load_Years
    ELSE IF @DefaultLoadYears IS NOT NULL
    BEGIN
        SET @LastLoadDate = DATEADD(YEAR, -@DefaultLoadYears, SYSDATETIME());
        SET @LoadDateSource = CONCAT('Initial Incremental: ', @DefaultLoadYears, ' years back');
    END
    -- Priority 3: Use_Full_History
    ELSE IF @UseFullHistory = 1
    BEGIN
        SET @LastLoadDate = '1900-01-01';
        SET @LoadDateSource = 'Use_Full_History (Incremental)';
    END
    -- Priority 4: Default_Load_Date
    ELSE IF @DefaultLoadDate IS NOT NULL
    BEGIN
        SET @LastLoadDate = @DefaultLoadDate;
        SET @LoadDateSource = 'Default_Load_Date (Incremental)';
    END
    -- Priority 5: Default_Load_Days
    ELSE IF @DefaultLoadDays IS NOT NULL
    BEGIN
        SET @LastLoadDate = DATEADD(DAY, -@DefaultLoadDays, SYSDATETIME());
        SET @LoadDateSource = CONCAT('Initial Incremental: ', @DefaultLoadDays, ' days');
    END
    -- Fallback (should rarely be reached)
    ELSE
    BEGIN
        SET @LastLoadDate = DATEADD(DAY, -7, SYSDATETIME());
        SET @LoadDateSource = 'Fallback default (7 days)';
    END
    
    RETURN 0;
END;
GO
/****** Object:  StoredProcedure [exe].[04_Check_Dependencies]    Script Date: 27-8-2025 13:37:43 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

-- =============================================
-- 2. DEPENDENCY PROCEDURES
-- =============================================

-- Check if dependencies are met
CREATE   PROCEDURE [exe].[04_Check_Dependencies]
    @TableName NVARCHAR(100),
    @System NVARCHAR(25),
    @Dependencies NVARCHAR(500),
    @DependenciesMet BIT OUTPUT,
    @UnmetDependencies NVARCHAR(500) OUTPUT
AS
BEGIN
    SET NOCOUNT ON;
    
    SET @DependenciesMet = 1;
    SET @UnmetDependencies = '';
    
    IF @Dependencies IS NULL OR @Dependencies = ''
        RETURN 0;
    
    -- Check each dependency
    SELECT @UnmetDependencies = STRING_AGG(dep.value, ', ')
    FROM STRING_SPLIT(@Dependencies, ',') AS dep
    LEFT JOIN [exe].[Table_List] AS tl 
        ON LTRIM(RTRIM(dep.value)) = tl.[Table_Name]
        AND tl.[System] = @System
    WHERE tl.[Load_Status] IS NULL 
       OR tl.[Load_Status] != 'S';
    
    IF @UnmetDependencies IS NOT NULL AND @UnmetDependencies != ''
    BEGIN
        SET @DependenciesMet = 0;
    END
    
    RETURN 0;
END;
GO
/****** Object:  StoredProcedure [exe].[05_Get_Unmet_Dependencies]    Script Date: 27-8-2025 13:37:43 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

-- Get list of unmet dependencies with details
CREATE   PROCEDURE [exe].[05_Get_Unmet_Dependencies]
    @TableName NVARCHAR(100),
    @System NVARCHAR(25)
AS
BEGIN
    SET NOCOUNT ON;
    
    DECLARE @Dependencies NVARCHAR(500);
    
    SELECT @Dependencies = [Dependencies]
    FROM [exe].[Table_List]
    WHERE [Table_Name] = @TableName AND [System] = @System;
    
    IF @Dependencies IS NULL OR @Dependencies = ''
    BEGIN
        SELECT 
            CAST(NULL AS NVARCHAR(100)) AS DependencyName,
            CAST(NULL AS CHAR(1)) AS LoadStatus,
            CAST(NULL AS DATETIME2(7)) AS LastLoadedDate
        WHERE 1 = 0;
        RETURN 0;
    END
    
    -- Return detailed dependency status
    SELECT 
        LTRIM(RTRIM(dep.value)) AS DependencyName,
        ISNULL(tl.[Load_Status], 'N') AS LoadStatus,
        tl.[Last_Loaded_Date] AS LastLoadedDate
    FROM STRING_SPLIT(@Dependencies, ',') AS dep
    LEFT JOIN [exe].[Table_List] AS tl 
        ON LTRIM(RTRIM(dep.value)) = tl.[Table_Name]
        AND tl.[System] = @System
    WHERE tl.[Load_Status] IS NULL 
       OR tl.[Load_Status] != 'S';
    
    RETURN 0;
END;
GO
/****** Object:  StoredProcedure [exe].[06_Create_Lineage_Entry]    Script Date: 27-8-2025 13:37:43 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

-- =============================================
-- 3. LINEAGE PROCEDURES
-- =============================================

-- Create lineage entry
CREATE   PROCEDURE [exe].[06_Create_Lineage_Entry]
    @System NVARCHAR(25),
    @TableName NVARCHAR(100),
    @LoadType CHAR(1),
    @LastLoadDate DATETIME2(7),
    @LoadDateSource NVARCHAR(50),
    @ForceStart BIT,
    @RetryCount INT,
    @MaxRetries INT,
    @LineageKey INT OUTPUT
AS
BEGIN
    SET NOCOUNT ON;
    SET XACT_ABORT ON;
    
    BEGIN TRY
        BEGIN TRANSACTION;
        
        -- Check for existing in-progress loads
        IF EXISTS (SELECT 1 FROM [exe].[Lineage] 
                  WHERE [Table_Name] = @TableName 
                  AND [System] = @System 
                  AND [Load_Status] = 'P')
           AND @ForceStart = 0
        BEGIN
            RAISERROR('Table %s has an in-progress load. Use ForceStart to override.', 16, 1, @TableName);
            RETURN -1;
        END
        
        -- Calculate average duration for estimation
        DECLARE @AvgDurationMinutes INT;
        SELECT @AvgDurationMinutes = AVG(DATEDIFF(MINUTE, [Start_Load], [Finish_Load]))
        FROM [exe].[Lineage]
        WHERE [Table_Name] = @TableName 
        AND [System] = @System 
        AND [Load_Status] = 'S'
        AND [Finish_Load] > DATEADD(DAY, -30, SYSDATETIME());
        
        -- Insert new lineage record
        INSERT INTO [exe].[Lineage] (
            [System],
            [Table_Name],
            [Start_Load],
            [Load_Status],
            [Type],
            [Last_Loaded_Date],
            [Output_Message],
            [Created_By],
            [Host_Name]
        )
        VALUES (
            @System,
            @TableName,
            SYSDATETIME(),
            'P',  -- In Progress
            @LoadType,
            @LastLoadDate,
            CONCAT(
                'Load started | Type: ', @LoadType,
                ' | From: ', CONVERT(NVARCHAR(30), @LastLoadDate, 120),
                ' | Source: ', @LoadDateSource,
                CASE WHEN @AvgDurationMinutes IS NOT NULL 
                     THEN CONCAT(' | Avg duration: ', @AvgDurationMinutes, ' min')
                     ELSE '' END,
                CASE WHEN @ForceStart = 1 THEN ' [FORCED]' ELSE '' END,
                CASE WHEN @RetryCount > 0 
                     THEN CONCAT(' [Retry ', @RetryCount, '/', @MaxRetries, ']')
                     ELSE '' END
            ),
            SUSER_SNAME(),
            HOST_NAME()
        );
        
        SET @LineageKey = SCOPE_IDENTITY();
        
        COMMIT TRANSACTION;
        RETURN 0;
    END TRY
    BEGIN CATCH
        IF @@TRANCOUNT > 0
            ROLLBACK TRANSACTION;
        THROW;
    END CATCH
END;
GO
/****** Object:  StoredProcedure [exe].[07_Update_Lineage_Status]    Script Date: 27-8-2025 13:37:43 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

-- Update lineage status
CREATE   PROCEDURE [exe].[07_Update_Lineage_Status]
    @LineageKey INT,
    @Status CHAR(1), -- P=Progress, S=Success, E=Error, W=Warning
    @OutputMessage NVARCHAR(MAX) = NULL
AS
BEGIN
    SET NOCOUNT ON;
    
    UPDATE [exe].[Lineage]
    SET 
        [Load_Status] = @Status,
        [Output_Message] = ISNULL(@OutputMessage, [Output_Message])
    WHERE [Lineage_Key] = @LineageKey;
    
    IF @@ROWCOUNT = 0
    BEGIN
        RAISERROR('LineageKey %d not found.', 16, 1, @LineageKey);
        RETURN -1;
    END
    
    RETURN 0;
END;
GO
/****** Object:  StoredProcedure [exe].[08_Record_Lineage_Metrics]    Script Date: 27-8-2025 13:37:43 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

-- Record lineage metrics
CREATE   PROCEDURE [exe].[08_Record_Lineage_Metrics]
    @LineageKey INT,
    @RowCount BIGINT = NULL,
    @RowsInserted BIGINT = NULL,
    @RowsUpdated BIGINT = NULL,
    @RowsDeleted BIGINT = NULL,
    @ErrorNumber INT = NULL,
    @ErrorSeverity INT = NULL,
    @ErrorState INT = NULL
AS
BEGIN
    SET NOCOUNT ON;
    
    UPDATE [exe].[Lineage]
    SET 
        [Row_Count] = ISNULL(@RowCount, [Row_Count]),
        [Rows_Inserted] = ISNULL(@RowsInserted, [Rows_Inserted]),
        [Rows_Updated] = ISNULL(@RowsUpdated, [Rows_Updated]),
        [Rows_Deleted] = ISNULL(@RowsDeleted, [Rows_Deleted]),
        [Error_Number] = ISNULL(@ErrorNumber, [Error_Number]),
        [Error_Severity] = ISNULL(@ErrorSeverity, [Error_Severity]),
        [Error_State] = ISNULL(@ErrorState, [Error_State]),
        [Finish_Load] = CASE 
            WHEN [Load_Status] IN ('S', 'E', 'W') 
            THEN SYSDATETIME() 
            ELSE [Finish_Load] 
        END
    WHERE [Lineage_Key] = @LineageKey;
    
    RETURN 0;
END;
GO
/****** Object:  StoredProcedure [exe].[09_Update_Table_Status]    Script Date: 27-8-2025 13:37:43 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

-- =============================================
-- 4. STATUS MANAGEMENT PROCEDURES
-- =============================================

-- Update table status
CREATE   PROCEDURE [exe].[09_Update_Table_Status]
    @TableName NVARCHAR(100),
    @System NVARCHAR(25),
    @Status CHAR(1),
    @OutputMessage NVARCHAR(MAX) = NULL,
    @UpdateLastLoadedDate BIT = 0
AS
BEGIN
    SET NOCOUNT ON;
    
    UPDATE [exe].[Table_List]
    SET 
        [Load_Status] = @Status,
        [Output_Message] = ISNULL(@OutputMessage, [Output_Message]),
        [Last_Loaded_Date] = CASE 
            WHEN @UpdateLastLoadedDate = 1 
            THEN SYSDATETIME() 
            ELSE [Last_Loaded_Date] 
        END,
        [Modified_Date] = SYSDATETIME(),
        [Modified_By] = SUSER_SNAME()
    WHERE [Table_Name] = @TableName 
    AND [System] = @System;
    
    RETURN 0;
END;
GO
/****** Object:  StoredProcedure [exe].[10_Reset_Retry_Count]    Script Date: 27-8-2025 13:37:43 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

-- Reset retry counter
CREATE   PROCEDURE [exe].[10_Reset_Retry_Count]
    @TableName NVARCHAR(100),
    @System NVARCHAR(25)
AS
BEGIN
    SET NOCOUNT ON;
    
    UPDATE [exe].[Table_List]
    SET 
        [Retry_Count] = 0,
        [Modified_Date] = SYSDATETIME(),
        [Modified_By] = SUSER_SNAME()
    WHERE [Table_Name] = @TableName 
    AND [System] = @System;
    
    RETURN 0;
END;
GO
/****** Object:  StoredProcedure [exe].[11_Increment_Retry_Count]    Script Date: 27-8-2025 13:37:43 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

-- Increment retry counter
CREATE   PROCEDURE [exe].[11_Increment_Retry_Count]
    @TableName NVARCHAR(100),
    @System NVARCHAR(25),
    @NewRetryCount INT OUTPUT,
    @MaxRetriesReached BIT OUTPUT
AS
BEGIN
    SET NOCOUNT ON;
    
    DECLARE @MaxRetries INT;
    
    UPDATE [exe].[Table_List]
    SET 
        [Retry_Count] = [Retry_Count] + 1,
        @NewRetryCount = [Retry_Count] + 1,
        @MaxRetries = [Max_Retries],
        [Modified_Date] = SYSDATETIME(),
        [Modified_By] = SUSER_SNAME()
    WHERE [Table_Name] = @TableName 
    AND [System] = @System;
    
    SET @MaxRetriesReached = CASE 
        WHEN @NewRetryCount >= @MaxRetries THEN 1 
        ELSE 0 
    END;
    
    RETURN 0;
END;
GO
/****** Object:  StoredProcedure [exe].[12_Execute_ETL_Procedure]    Script Date: 27-8-2025 13:37:43 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

-- =============================================
-- 5. EXECUTION PROCEDURES
-- =============================================

-- Execute single ETL procedure
CREATE   PROCEDURE [exe].[12_Execute_ETL_Procedure]
    @StoredProcedureName NVARCHAR(200),
    @LineageKey INT,
    @LoadType CHAR(1),
    @LastLoadDate DATETIME2(7),
    @ExecutionResult INT OUTPUT,
    @ExecutionMessage NVARCHAR(MAX) OUTPUT
AS
BEGIN
    SET NOCOUNT ON;
    
    DECLARE @SQL NVARCHAR(MAX);
    DECLARE @Params NVARCHAR(500);
    
    BEGIN TRY
        -- Build dynamic SQL
        SET @SQL = CONCAT('EXEC ', @StoredProcedureName, ' @LineageKey = @p_LineageKey');
        
        -- Add optional parameters if the procedure supports them
        SET @SQL = @SQL + ', @LoadType = @p_LoadType';
        SET @SQL = @SQL + ', @LastLoadDate = @p_LastLoadDate';
        
        SET @Params = N'@p_LineageKey INT, @p_LoadType CHAR(1), @p_LastLoadDate DATETIME2(7)';
        
        -- Execute the procedure
        EXEC sp_executesql 
            @SQL, 
            @Params,
            @p_LineageKey = @LineageKey,
            @p_LoadType = @LoadType,
            @p_LastLoadDate = @LastLoadDate;
        
        SET @ExecutionResult = 0;
        SET @ExecutionMessage = 'Procedure executed successfully';
    END TRY
    BEGIN CATCH
        SET @ExecutionResult = -1;
        SET @ExecutionMessage = ERROR_MESSAGE();
    END CATCH
    
    RETURN @ExecutionResult;
END;
GO
/****** Object:  StoredProcedure [exe].[13_Get_Next_Table]    Script Date: 27-8-2025 13:37:43 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [exe].[13_Get_Next_Table]
    @System NVARCHAR(25) = NULL,
    @RunGroup NVARCHAR(250) = NULL,
    @LoadType CHAR(1) = NULL,
    @ExecutionOrder INT,
    @TableName NVARCHAR(100) OUTPUT,
    @TableSystem NVARCHAR(25) OUTPUT,
    @StoredProcedureName NVARCHAR(200) OUTPUT,
    @TableLoadType CHAR(1) OUTPUT,
    @Dependencies NVARCHAR(500) OUTPUT
AS
BEGIN
    SET NOCOUNT ON;
    
    SELECT TOP 1
        @TableName = [Table_Name],
        @TableSystem = [System],
        @StoredProcedureName = [Stored_Procedure_Name],
        @TableLoadType = ISNULL(@LoadType, [Load_Type]),
        @Dependencies = [Dependencies]
    FROM [exe].[Table_List]
    WHERE (@System IS NULL OR [System] = @System)
        AND [Is_Active] = 1
        AND (@RunGroup IS NULL OR [Run_Group] = @RunGroup)
        AND [Execution_Order] = @ExecutionOrder
        AND ([Load_Status] IS NULL OR [Load_Status] NOT IN ('P', 'R'))
    ORDER BY [Table_Name];
    
    RETURN 0;
END;
GO
/****** Object:  StoredProcedure [exe].[14_Check_InProgress_Loads]    Script Date: 27-8-2025 13:37:43 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

-- =============================================
-- 6. MONITORING PROCEDURES
-- =============================================

-- Check for in-progress loads
CREATE   PROCEDURE [exe].[14_Check_InProgress_Loads]
    @TableName NVARCHAR(100),
    @System NVARCHAR(25),
    @HasInProgress BIT OUTPUT,
    @InProgressMinutes INT OUTPUT,
    @InProgressLineageKey INT OUTPUT
AS
BEGIN
    SET NOCOUNT ON;
    
    SET @HasInProgress = 0;
    SET @InProgressMinutes = 0;
    SET @InProgressLineageKey = NULL;
    
    SELECT TOP 1
        @HasInProgress = 1,
        @InProgressMinutes = DATEDIFF(MINUTE, [Start_Load], SYSDATETIME()),
        @InProgressLineageKey = [Lineage_Key]
    FROM [exe].[Lineage]
    WHERE [Table_Name] = @TableName 
    AND [System] = @System 
    AND [Load_Status] = 'P'
    ORDER BY [Start_Load] DESC;
    
    RETURN 0;
END;
GO
/****** Object:  StoredProcedure [exe].[15_Calculate_Average_Duration]    Script Date: 27-8-2025 13:37:43 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

-- Calculate average duration
CREATE   PROCEDURE [exe].[15_Calculate_Average_Duration]
    @TableName NVARCHAR(100),
    @System NVARCHAR(25),
    @DaysBack INT = 30,
    @AvgDurationMinutes INT OUTPUT,
    @MinDurationMinutes INT OUTPUT,
    @MaxDurationMinutes INT OUTPUT
AS
BEGIN
    SET NOCOUNT ON;
    
    SELECT 
        @AvgDurationMinutes = AVG(DATEDIFF(MINUTE, [Start_Load], [Finish_Load])),
        @MinDurationMinutes = MIN(DATEDIFF(MINUTE, [Start_Load], [Finish_Load])),
        @MaxDurationMinutes = MAX(DATEDIFF(MINUTE, [Start_Load], [Finish_Load]))
    FROM [exe].[Lineage]
    WHERE [Table_Name] = @TableName 
    AND [System] = @System 
    AND [Load_Status] = 'S'
    AND [Finish_Load] > DATEADD(DAY, -@DaysBack, SYSDATETIME());
    
    RETURN 0;
END;
GO
/****** Object:  StoredProcedure [exe].[16_Get_Execution_Metrics]    Script Date: 27-8-2025 13:37:43 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

-- Get execution metrics
CREATE   PROCEDURE [exe].[16_Get_Execution_Metrics]
    @System NVARCHAR(25) = NULL,
    @RunGroup NVARCHAR(250) = NULL,
    @DaysBack INT = 7
AS
BEGIN
    SET NOCOUNT ON;
    
    SELECT 
        l.[System],
        l.[Table_Name],
        COUNT(*) AS TotalExecutions,
        SUM(CASE WHEN l.[Load_Status] = 'S' THEN 1 ELSE 0 END) AS SuccessfulExecutions,
        SUM(CASE WHEN l.[Load_Status] = 'E' THEN 1 ELSE 0 END) AS FailedExecutions,
        AVG(DATEDIFF(MINUTE, l.[Start_Load], l.[Finish_Load])) AS AvgDurationMinutes,
        MAX(l.[Finish_Load]) AS LastExecutionTime,
        AVG(l.[Row_Count]) AS AvgRowCount
    FROM [exe].[Lineage] l
    INNER JOIN [exe].[Table_List] tl 
        ON l.[Table_Name] = tl.[Table_Name] 
        AND l.[System] = tl.[System]
    WHERE l.[Start_Load] > DATEADD(DAY, -@DaysBack, SYSDATETIME())
        AND (@System IS NULL OR l.[System] = @System)
        AND (@RunGroup IS NULL OR tl.[Run_Group] = @RunGroup)
    GROUP BY l.[System], l.[Table_Name]
    ORDER BY l.[System], l.[Table_Name];
    
    RETURN 0;
END;
GO
/****** Object:  StoredProcedure [exe].[17_Master_ETL_Controller]    Script Date: 27-8-2025 13:37:43 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
	
  
						   
	 
  
	  
  

			
				  
			
CREATE PROCEDURE [exe].[17_Master_ETL_Controller]
    @System NVARCHAR(25) = NULL,
    @RunGroup NVARCHAR(250) = NULL,
    @OverrideLoadType CHAR(1) = NULL,
    @MaxParallelJobs INT = 5,
    @ForceStart BIT = 0,
    @DebugMode BIT = 0,
    @AutoFixStuck BIT = 0
AS
BEGIN
    SET NOCOUNT ON;
    
    -- Variables
    DECLARE @StartTime DATETIME2(7) = SYSDATETIME();
    DECLARE @TableName NVARCHAR(100);
    DECLARE @TableSystem NVARCHAR(25);
    DECLARE @StoredProcedureName NVARCHAR(200);
    DECLARE @LineageKey INT;
    DECLARE @LastLoadDate DATETIME2(7);
    DECLARE @LoadDateSource NVARCHAR(50);
    DECLARE @LoadTypeActual CHAR(1);
    DECLARE @ConfiguredLoadType CHAR(1);
    DECLARE @Dependencies NVARCHAR(500);
    DECLARE @IsValid BIT;
    DECLARE @ValidationMessage NVARCHAR(500);
    DECLARE @DependenciesMet BIT;
    DECLARE @UnmetDependencies NVARCHAR(500);
    DECLARE @HasInProgress BIT;
    DECLARE @InProgressMinutes INT;
    DECLARE @InProgressLineageKey INT;
    DECLARE @ExecutionResult INT;
    DECLARE @ExecutionMessage NVARCHAR(MAX);
    DECLARE @OutputMessage NVARCHAR(MAX);
    DECLARE @CurrentExecutionOrder INT = 0;
    DECLARE @MaxExecutionOrder INT;
    DECLARE @ProcessedCount INT = 0;
    DECLARE @SuccessCount INT = 0;
    DECLARE @ErrorCount INT = 0;
    DECLARE @SkippedCount INT = 0;
    DECLARE @RetryCount INT;
    DECLARE @MaxRetries INT;
    DECLARE @NewRetryCount INT;
    DECLARE @MaxRetriesReached BIT;
    DECLARE @OverrideFullLoad BIT = 0;
    DECLARE @PreCheckResult INT;
    DECLARE @StatusMessage NVARCHAR(MAX);  -- Declare once at top level
    
    -- Configuration variables
    DECLARE @SchemaName NVARCHAR(128);
    DECLARE @IsActive BIT;
    DECLARE @ExecutionOrder INT;
    DECLARE @RunGroupConfig NVARCHAR(50);
    DECLARE @TimeoutSeconds INT;
    DECLARE @DefaultLoadDays INT;
    DECLARE @DefaultLoadDate DATETIME2(7);
    DECLARE @UseFullHistory BIT;
    DECLARE @DefaultLoadYears INT;
    DECLARE @Exists BIT;
    
    -- ALWAYS run pre-check
    EXEC @PreCheckResult = [exe].[00_PreCheck_Tables]
        @System = @System,
        @RunGroup = @RunGroup,
        @ShowDetails = @DebugMode,
        @AutoFix = @AutoFixStuck,
        @OverrideLoadType = @OverrideLoadType;
    
    -- If issues found and not forcing or auto-fixing
    IF @PreCheckResult > 0 AND @ForceStart = 0 AND @AutoFixStuck = 0
    BEGIN
								  
        SELECT 
            0 AS TablesProcessed,
            0 AS TablesSucceeded,
            0 AS TablesFailed,
            0 AS TablesSkipped,
            0 AS TotalDurationSeconds,
            'Pre-check failed - see details above' AS Summary;
        
        RETURN 1;
    END
    
    -- If auto-fix was applied, show clean state
    IF @PreCheckResult > 0 AND @AutoFixStuck = 1
    BEGIN
        PRINT '';
        EXEC @PreCheckResult = [exe].[00_PreCheck_Tables]
            @System = @System,
            @RunGroup = @RunGroup,
            @ShowDetails = 0,
            @AutoFix = 0,
            @OverrideLoadType = @OverrideLoadType;
    END
    
    -- Simple header for execution
    PRINT '';
    PRINT '========================================';
    PRINT 'EXECUTING ETL PROCESSES';
    PRINT '========================================';
    PRINT CONCAT('Start Time: ', CONVERT(NVARCHAR(30), @StartTime, 120));
    PRINT '';
    
    -- Get max execution order
    SELECT @MaxExecutionOrder = MAX([Execution_Order])
    FROM [exe].[Table_List]
    WHERE (@System IS NULL OR [System] = @System)
        AND [Is_Active] = 1
        AND (@RunGroup IS NULL OR [Run_Group] = @RunGroup);
					 
    
    -- Process each execution order level
    WHILE @CurrentExecutionOrder <= @MaxExecutionOrder
    BEGIN
        -- Get next table
        EXEC [exe].[13_Get_Next_Table]
            @System = @System,
            @RunGroup = @RunGroup,
            @LoadType = @OverrideLoadType,
            @ExecutionOrder = @CurrentExecutionOrder,
            @TableName = @TableName OUTPUT,
            @TableSystem = @TableSystem OUTPUT,
            @StoredProcedureName = @StoredProcedureName OUTPUT,
            @TableLoadType = @LoadTypeActual OUTPUT,
            @Dependencies = @Dependencies OUTPUT;
        
        WHILE @TableName IS NOT NULL
        BEGIN
            SET @ProcessedCount = @ProcessedCount + 1;
            
            IF @DebugMode = 1
                PRINT CONCAT('[', FORMAT(@ProcessedCount, '00'), '] ', @TableSystem, '.', @TableName);
            
            -- Get full configuration
            EXEC [exe].[01_Get_Table_Config]
                @TableName = @TableName,
                @System = @TableSystem,
                @SchemaName = @SchemaName OUTPUT,
                @StoredProcedureName = @StoredProcedureName OUTPUT,
                @IsActive = @IsActive OUTPUT,
                @LoadType = @ConfiguredLoadType OUTPUT,
                @ExecutionOrder = @ExecutionOrder OUTPUT,
                @RunGroup = @RunGroupConfig OUTPUT,
                @Dependencies = @Dependencies OUTPUT,
                @MaxRetries = @MaxRetries OUTPUT,
                @RetryCount = @RetryCount OUTPUT,
                @TimeoutSeconds = @TimeoutSeconds OUTPUT,
                @DefaultLoadDays = @DefaultLoadDays OUTPUT,
                @DefaultLoadDate = @DefaultLoadDate OUTPUT,
                @UseFullHistory = @UseFullHistory OUTPUT,
                @DefaultLoadYears = @DefaultLoadYears OUTPUT,
                @Exists = @Exists OUTPUT;
            
            -- Use override if specified
            IF @OverrideLoadType IS NOT NULL
            BEGIN
                SET @LoadTypeActual = @OverrideLoadType;
                SET @OverrideFullLoad = CASE WHEN @OverrideLoadType = 'F' AND @ConfiguredLoadType = 'I' THEN 1 ELSE 0 END;
                
                IF @DebugMode = 1 AND @LoadTypeActual != @ConfiguredLoadType
                    PRINT CONCAT('    Type override: ', @ConfiguredLoadType, ' -> ', @LoadTypeActual);
            END
            ELSE
            BEGIN
                SET @LoadTypeActual = @ConfiguredLoadType;
                SET @OverrideFullLoad = 0;
            END
            
            -- Validate table
            EXEC [exe].[02_Validate_Table]
                @TableName = @TableName,
                @System = @TableSystem,
                @LoadType = @LoadTypeActual,
                @IsValid = @IsValid OUTPUT,
                @ValidationMessage = @ValidationMessage OUTPUT;
            
            IF @IsValid = 0
            BEGIN
                IF @DebugMode = 1
                    PRINT CONCAT('    SKIP: ', @ValidationMessage);
                
                SET @SkippedCount = @SkippedCount + 1;
                GOTO NextTable;
            END
            
            -- Check for in-progress loads
            EXEC [exe].[14_Check_InProgress_Loads]
                @TableName = @TableName,
                @System = @TableSystem,
                @HasInProgress = @HasInProgress OUTPUT,
                @InProgressMinutes = @InProgressMinutes OUTPUT,
                @InProgressLineageKey = @InProgressLineageKey OUTPUT;
            
            IF @HasInProgress = 1 AND @ForceStart = 0
            BEGIN
                IF @DebugMode = 1
                    PRINT CONCAT('    SKIP: In-progress (', @InProgressMinutes, ' min)');
                
                SET @SkippedCount = @SkippedCount + 1;
                GOTO NextTable;
            END
            
            -- Check dependencies
            EXEC [exe].[04_Check_Dependencies]
                @TableName = @TableName,
                @System = @TableSystem,
                @Dependencies = @Dependencies,
                @DependenciesMet = @DependenciesMet OUTPUT,
                @UnmetDependencies = @UnmetDependencies OUTPUT;
            
            IF @DependenciesMet = 0 AND @ForceStart = 0
            BEGIN
                IF @DebugMode = 1
                    PRINT CONCAT('    SKIP: Unmet dependencies (', @UnmetDependencies, ')');
                
                SET @SkippedCount = @SkippedCount + 1;
                GOTO NextTable;
            END
            
            -- Calculate load date
            EXEC [exe].[03_Calculate_Load_Date]
                @TableName = @TableName,
                @System = @TableSystem,
                @LoadType = @LoadTypeActual,
                @OverrideFullLoad = @OverrideFullLoad,
                @LastLoadDate = @LastLoadDate OUTPUT,
                @LoadDateSource = @LoadDateSource OUTPUT;
            
            IF @DebugMode = 1
                PRINT CONCAT('    Load from: ', CONVERT(VARCHAR(30), @LastLoadDate, 120));
            
            BEGIN TRY
                -- Create lineage entry
                EXEC [exe].[06_Create_Lineage_Entry]
                    @System = @TableSystem,
                    @TableName = @TableName,
                    @LoadType = @LoadTypeActual,
                    @LastLoadDate = @LastLoadDate,
                    @LoadDateSource = @LoadDateSource,
                    @ForceStart = @ForceStart,
                    @RetryCount = @RetryCount,
                    @MaxRetries = @MaxRetries,
                    @LineageKey = @LineageKey OUTPUT;
                
                -- Build and use status message
                SET @StatusMessage = CONCAT('Processing with LineageKey: ', @LineageKey,
                    CASE WHEN @OverrideFullLoad = 1 THEN ' [FULL LOAD OVERRIDE]' ELSE '' END);
                
                EXEC [exe].[09_Update_Table_Status]
                    @TableName = @TableName,
                    @System = @TableSystem,
                    @Status = 'P',
                    @OutputMessage = @StatusMessage;
                
                -- Execute the ETL procedure
                EXEC [exe].[12_Execute_ETL_Procedure]
                    @StoredProcedureName = @StoredProcedureName,
                    @LineageKey = @LineageKey,
                    @LoadType = @LoadTypeActual,
                    @LastLoadDate = @LastLoadDate,
                    @ExecutionResult = @ExecutionResult OUTPUT,
                    @ExecutionMessage = @ExecutionMessage OUTPUT;
                
                IF @ExecutionResult = 0
                BEGIN
                    -- Update lineage to success
                    EXEC [exe].[07_Update_Lineage_Status]
                        @LineageKey = @LineageKey,
                        @Status = 'S',
                        @OutputMessage = 'Completed successfully';
                    
                    -- Update table status to success
                    SET @StatusMessage = CONCAT('Successfully loaded ', @TableName);
                    
                    EXEC [exe].[09_Update_Table_Status]
                        @TableName = @TableName,
                        @System = @TableSystem,
                        @Status = 'S',
                        @OutputMessage = @StatusMessage,
                        @UpdateLastLoadedDate = 1;
                    
                    -- Reset retry count on success
                    EXEC [exe].[10_Reset_Retry_Count]
                        @TableName = @TableName,
                        @System = @TableSystem;
                    
                    SET @SuccessCount = @SuccessCount + 1;
                    
                    IF @DebugMode = 1
                        PRINT '    SUCCESS';
                END
                ELSE
                BEGIN
                    RAISERROR(@ExecutionMessage, 16, 1);
                END
            END TRY
            BEGIN CATCH
                DECLARE @ErrorMessage NVARCHAR(4000) = ERROR_MESSAGE();
                DECLARE @ErrorNumber INT = ERROR_NUMBER();
                DECLARE @ErrorSeverity INT = ERROR_SEVERITY();
                DECLARE @ErrorState INT = ERROR_STATE();
                
                -- Update lineage with error
                IF @LineageKey IS NOT NULL
                BEGIN
                    EXEC [exe].[07_Update_Lineage_Status]
                        @LineageKey = @LineageKey,
                        @Status = 'E',
                        @OutputMessage = @ErrorMessage;
                    
                    EXEC [exe].[08_Record_Lineage_Metrics]
                        @LineageKey = @LineageKey,
                        @ErrorNumber = @ErrorNumber,
                        @ErrorSeverity = @ErrorSeverity,
                        @ErrorState = @ErrorState;
                END
                
                -- Update table status to error
                EXEC [exe].[09_Update_Table_Status]
                    @TableName = @TableName,
                    @System = @TableSystem,
                    @Status = 'E',
                    @OutputMessage = @ErrorMessage;
                
                -- Increment retry count
                EXEC [exe].[11_Increment_Retry_Count]
                    @TableName = @TableName,
                    @System = @TableSystem,
                    @NewRetryCount = @NewRetryCount OUTPUT,
                    @MaxRetriesReached = @MaxRetriesReached OUTPUT;
                
                SET @ErrorCount = @ErrorCount + 1;
                
                IF @DebugMode = 1
                    PRINT CONCAT('    ERROR: ', LEFT(@ErrorMessage, 60));
            END CATCH
            
            NextTable:
			 
            SET @TableName = NULL;
            SET @LineageKey = NULL;
            
            EXEC [exe].[13_Get_Next_Table]
                @System = @System,
                @RunGroup = @RunGroup,
                @LoadType = @OverrideLoadType,
                @ExecutionOrder = @CurrentExecutionOrder,
                @TableName = @TableName OUTPUT,
                @TableSystem = @TableSystem OUTPUT,
                @StoredProcedureName = @StoredProcedureName OUTPUT,
                @TableLoadType = @LoadTypeActual OUTPUT,
                @Dependencies = @Dependencies OUTPUT;
        END
        
        SET @CurrentExecutionOrder = @CurrentExecutionOrder + 1;
    END
    
    -- Final summary
    SET @OutputMessage = CONCAT(
        'ETL completed: ',
        @ProcessedCount, ' processed, ',
        @SuccessCount, ' success, ',
        @ErrorCount, ' errors, ',
        @SkippedCount, ' skipped ',
        '(', DATEDIFF(SECOND, @StartTime, SYSDATETIME()), 's)'
    );
    
    PRINT '';
   
	 
    PRINT '========================================';
    PRINT @OutputMessage;
    PRINT '========================================';
	
    
    -- Return summary result set
    SELECT 
        @ProcessedCount AS TablesProcessed,
        @SuccessCount AS TablesSucceeded,
        @ErrorCount AS TablesFailed,
        @SkippedCount AS TablesSkipped,
        DATEDIFF(SECOND, @StartTime, SYSDATETIME()) AS TotalDurationSeconds,
        @OutputMessage AS Summary;
    
    -- Show execution metrics in debug mode
    IF @DebugMode = 1
    BEGIN
        PRINT '';
        EXEC [exe].[16_Get_Execution_Metrics]
            @System = @System,
            @RunGroup = @RunGroup,
            @DaysBack = 1;
    END
    
    -- Return exit code
    IF @ErrorCount > 0
        RETURN 1;
    ELSE
        RETURN 0;
END;
GO
